---
title: "DE Quick View for time-course"
author: "Kimon Froussios"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float:
      collapsed: false
params:
  selfname: ""
  dds: NULL     # MUST be specified, DESeq2 object
  prefix: ""
  resultsDir: "."
  baseDir: "."
  pcutoff: 0.05
  lfcthreshold: 1
  ntop: 50             # maximum number of hits to list
  minMean: 10          # Minimum sum of counts across samples per gene (already applied, just here for parameter documentation in the report)
  minSingle: 100
  filterBaseMean: TRUE  # DESeq2 independent filtering
  reducedFormula: NULL
  longlabel: FALSE     # Prepend comparison info to standard column names.
  covars: NULL
  widths: NULL         # Feature lengths table.
  specnorm: NULL
  rlog: TRUE          # FALSE for VST instead
  comparisons: NULL        # List of 3-element character vectors for DESeq results(contrast=)
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, bitmapType='cairo-png')
```


# Setup

```{r libraries}
library(DESeq2)
library(data.table)
library(ggplot2)
# library(plotly)
library(htmltools)
library(patchwork)
library(ggrepel)
library(ggdendro)
library(DT)

# ggplot2 base theme
theme_set(theme_bw())

data.table::setDTthreads(1L)

options(scipen=2)

if (!is.null(params$reducedFormula)){
  if (params$reducedFormula == 'NULL') {
    params$reducedFormula <- NULL
  }
}
```

```{r preprocess}
# DESeq2 object set up with he relevant materials for this comparison formula
#deobj <- params$dds

# Variance-regularized counts
if (params$rlog) {
  vst <- rlog(params$dds, blind = TRUE)
} else {
  vst <- vst(params$dds, blind=TRUE)
}
vstmat <- assay(vst)

# TPM/RPM
normscale <- function(counts, featLens=NULL, specnorm=params$specnorm){
  if (!is.null(featLens)) {
    # Reorder/subset
    setkeyv(featLens, names(featLens)[1])
    featLens <- featLens[rownames(counts)]
    stopifnot(all(!is.na(featLens[, 2])))  # incomplete lengths
    # Scale by feature size
    TPMs <- sweep(counts, 1, featLens[[2]], `/`)
  }
  # Scale by sequencing depth
  if (!is.null(specnorm)) {
    colsums <- colSums(TPMs[!grepl(specnorm, rownames(TPMs), ignore.case=TRUE, perl=TRUE), ], na.rm=TRUE)  # MOUSE only!
  } else {
    colsums <- colSums(TPMs, na.rm=TRUE)
  }
  TPMs <- sweep(TPMs, 2, colsums, `/`) * 1e6
  
  return(TPMs)
}

tpm <- normscale(counts(params$dds, normalized = FALSE, replaced = FALSE), params$widths)

if (is.null(params$widths)){
  message('Scaled counts to RPM.')
  colsuffix <- 'RPM'
#  colnames(tpm) <- paste0(colnames(tpm), '.RPM')
} else {
  message('Scaled counts to TPM.')
  colsuffix <- 'TPM'
#  colnames(tpm) <- paste0(colnames(tpm), '.TPM')
}


# Covariates
cD <- colData(params$dds)[, 1:length(colData(params$dds)), drop=FALSE]  # before model building there in no size factor as last column

cat(paste("Min required mean raw counts across relevant samples:", params$minMean))
cat(paste("Min required raw count in a single sample when the min mean is not met:", params$minSingle))
cat(paste("DESeq2 independent filtering:", params$filterBaseMean))
cat(paste("Significance level:", params$pcutoff))
cat(paste0("log2FC threshold: ", params$lfcthreshold, " , (i.e. ", round(2 ^ params$lfcthreshold, 2), "-fold change)"))
cat(paste("Max number of top hits to highlight:", params$ntop))
cat(paste("Variance regularized counts type: ", ifelse(params$rlog, "rlog", "VST")))
cat(paste("Genes excluded from library size calculations (only affects TPM/RPM, does not affect DESeq2):", params$specnorm))

print( datatable(params$covars) )
```

# PCA

```{r pca, fig.width=8, fig.width=8}
for (x in names(cD)) {
  print( plotPCA(vst, intgroup=x) + labs(title=x) + coord_fixed() )
}
```

# Correlations

```{r functionC}
# Correlations
my_pairwise_internal_corels <- function(mat, samples, method = "pearson", rds=NULL, txs=3, minMean=0, minSingle=0) {
  # mat <- vstmat; samples <- colnames(rpm)
  
  # Filter
  if (minMean != 0 | minSingle != 0) {
    mat <- mat[rowSums(mat >= minSingle) >= 1 | rowMeans(mat) >= minMean, ]
  } else {
    mat <- mat[rowSums(mat) > 0, ]
  }
  
  # Correlations
  cormat <- cor(mat, method=method)
  
  # Cluster
  hcfit <- hclust(dist(scale(cormat, center=TRUE)))
  rn <- rownames(cormat)
  
  # Make dendrogram. https://stackoverflow.com/questions/42047896/joining-a-dendrogram-and-a-heatmap
  dend <- as.dendrogram(hcfit)
  dend_data <- dendro_data(dend)
  # Setup the data, so that the axes are exchanged, instead of using coord_flip()
  segment_data <- with(
      segment(dend_data), 
      data.frame(x = y, y = x, xend = yend, yend = xend))
  # Use the dendrogram label data to position the sample labels
  sample_pos_table <- with(
      dend_data$labels, 
      data.frame(y_center = x, Sample = as.character(label), height = 1))
  # Limits for the vertical axes
  sample_axis_limits <- with(
      sample_pos_table, 
      c(min(y_center - 0.5 * height), max(y_center + 0.5 * height))
  ) + 0.1 * c(-1, 1) # extra spacing: 0.1
  # Dendrogram plot
  pd <- ggplot(segment_data) + 
    geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) + 
    scale_x_reverse(expand = c(0, 0.5),
                    position = "top") + 
    scale_y_continuous(position = "right",
                       breaks = sample_pos_table$y_center, 
                       labels = sample_pos_table$Sample, 
                       limits = sample_axis_limits, 
                       expand = c(0, 0)) + 
    labs(x = NULL, y = NULL) +
    theme_minimal() + 
    theme(panel.grid = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank())

  
  # Create duplicates for different plot styles
  cormat <- cormat[samples, samples]                    # Supplied order
  cormat2 <- cormat                                     # Duplicate in which to delete below the diagonal.
  cormat3 <- cormat[rn[hcfit$order], rn[hcfit$order]]   # Duplicate in clustered order.
  cormat4 <- cormat3                                    # Duplicate in clustered order in which to delete below the diagonal.
  # Delete below diagonal half for the numeric labels.
  for (r in 1:nrow(cormat2)) {
    for (c in 1:ncol(cormat2)) {
      if (c <= r) {
        cormat2[r, c] <- NA_real_
      }
    }
  }
  for (r in 1:nrow(cormat4)) {
    for (c in 1:ncol(cormat4)) {
      if (c <= r) {
        cormat4[r, c] <- NA_real_
      }
    }
  }
  
  # Restructure for plotting.
  rn <- rownames(cormat)
  cormat <- as.data.table(cormat)
  cormat[, observation1 := factor(rn, ordered=TRUE, levels=rn)]
  cormat <- melt(cormat, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat[, observation2 := factor(observation2, ordered=TRUE, levels=rn)]
  # cormat <- merge(cormat, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  rn2 <- rownames(cormat2)
  cormat2 <- as.data.table(cormat2)
  cormat2[, observation1 := factor(rn2, ordered=TRUE, levels=rn2)]
  cormat2 <- melt(cormat2, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat2[, observation2 := factor(observation2, ordered=TRUE, levels=rn2)]
  cormat2 <- cormat2[!is.na(Correlation)]
  # cormat2 <- merge(cormat2, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  rn3 <- rownames(cormat3)
  cormat3 <- as.data.table(cormat3)
  cormat3[, observation1 := factor(rn3, ordered=TRUE, levels=rn3)]
  cormat3 <- melt(cormat3, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat3[, observation2 := factor(observation2, ordered=TRUE, levels=rn3)]
  # cormat3 <- merge(cormat3, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  rn4 <- rownames(cormat4)
  cormat4 <- as.data.table(cormat4)
  cormat4[, observation1 := factor(rn3, ordered=TRUE, levels=rn4)]
  cormat4 <- melt(cormat4, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat4[, observation2 := factor(observation2, ordered=TRUE, levels=rn4)]
  cormat4 <- cormat4[!is.na(Correlation)]
  # cormat4 <- merge(cormat4, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  # Text colour switch for the dynamic range
  m <- min(cormat4$Correlation, na.rm=TRUE)
  M <- max(cormat4$Correlation, na.rm=TRUE)
  colourswitch <- c( m + 0.49 * (M-m),  m + 0.51 * (M-m) )
  
  
  # Square. Custom order. No values. Full range.
  p1 <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )

  # Square. Custom order. No values. Dynamic range.
  p1a <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )

  # Triangle. Custom order. With values. Full range.
  p2 <- ggplot(cormat2, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )

  # Triangle. Custom order. With values. Dynamic range.
  p2a <- ggplot(cormat2, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )

  # Square. Custom order. With values. Full range.
  p12 <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat2, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )

  # Square. Custom order. With values. Dyhamic range.
  p12a <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat2, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )

  
  # Square. Clustered order. No values. Full range.
  p3 <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )

  # Square. Clustered order. No values. Dyhamic range.
  p3a <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )

  # Triangle. Clustered order. with values. Full range.
  p4 <- ggplot(cormat4, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )

  # Triangle. Clustered order. with values. Dyhamic range.
  p4a <- ggplot(cormat4, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Clustered order. With values. Full range.
  p34 <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat4, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )

  # Square. Clustered order. With values. Dyhamic range.
  p34a <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat4, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )

  out <- list(corr=dcast(cormat2, observation1 ~ observation2, value.var = "Correlation"),
              sfrnc=p1, sdrnc=p1a, 
              # tfrnc=p2, tdrnc=p2a,
              frnc=p12, drnc=p12a,
              sfrc=p3 + plot_layout(ncol=2, widths=c(1,4)), 
              sdrc=pd + p3a + plot_layout(ncol=2, widths=c(1,4)),
              # tfrc=p4, tdrc=p4a,
              frc=pd + p34 + plot_layout(ncol=2, widths=c(1,4)),
              drc=pd + p34a + plot_layout(ncol=2, widths=c(1,4))
              )
  
  if (!is.null(rds)) {
    saveRDS(out, file = rds)
  }
  
  return(out)
}
```

## TPM (or RPM)

```{r correlations1, fig.height=8, fig.width=8}
# corels1p <- my_pairwise_internal_corels(log2(tpm), colnames(tpm), method="pearson",
#                                        minMean=0, minSingle=0)   # pre-filtered when making the DESeq object
corels1s <- my_pairwise_internal_corels(tpm, colnames(tpm), method="spearman",
                                       minMean=0, minSingle=0)

# print( (corels1p[['sfrnc']] + theme(legend.position="none")) |
#          (corels1s[['sfrnc']] + theme(axis.text.y=element_blank())) )
print( corels1s[['sfrnc']] )
```

```{r correlations2, fig.height=8, fig.width=10}
# print( (corels1p[['sdrc']]) / (corels1s[['sdrc']] + theme(axis.text.x=element_blank())) )
print( corels1s[['sdrc']] )
```

## rlog (or VST)

```{r correlations3, fig.height=8, fig.width=8}
corels2p <- my_pairwise_internal_corels(vstmat, colnames(tpm), method="pearson", 
                                       minMean=0, minSingle=0)
# corels2s <- my_pairwise_internal_corels(vstmat, colnames(tpm), method="spearman", 
#                                        minMean=0, minSingle=0)

# print( (corels2p[['sfrnc']] + theme(legend.position="none")) | (corels2s[['sfrnc']] + theme(axis.text.y=element_blank())) )
print( corels2p[['sfrnc']] )
# print( corels2s[['sfrnc']] )
# The axes and fill range are deterministic and fixed, so I can drop the redundant details.
```

```{r correlations4, fig.height=8, fig.width=10}
# print( (corels2p[['sdrc']]) / (corels2s[['sdrc']] + theme(axis.text.x=element_blank())) )
print( corels2p[['sdrc']] )
# print( corels2s[['sdrc']] )
```



# DE

The highlighted red points are the up to `r params$ntop` top hits out of all the points that meet the thresholds. This number limit is arbitrary and serves mainly to allow the convenience of labelling potentially interesting hits while also preventing over-crowding the plots. "Top-ness" of hits is ranked roughly based on their "distance" from the origin of the axes in the volcano plots,

If a contrast does not have any hits that meet the thresholds defined at the beginning of this report, a warning message will indicate that there are no hits, and there will be no highlighted points. Instead, the `r params$ntop` "top-est" non-hit points will be listed in the table and shown in the interactive plots for exploration.


## Global

Using the Likelihood Ratio test to compare a DE model against a null model, across all provided samples. This analysis highlights features that show changes that are likely not attributable to the null model. It does not pinpoint those changes to a particular condition or particular pairwise comparison. This type of analysis is used either to find targets among any of multiple conditions or to isolate the influence of variables of interest from that of other variables.

### Significance

```{r DEg_p, fig.height=8, fig.width=12}
if (is.null(params$reducedFormula)) {
  cat("No formula provided. Skipping this analysis...\n")
} else {
  # Build model
  deobj <- DESeq(params$dds, test='LRT', reduced = as.formula(params$reducedFormula))
  
  cD <- colData(deobj)[, 1:length(colData(deobj)), drop=FALSE]
  cD <- data.table(Sample=rownames(cD), as.data.frame(cD))
  grp <- as.character(deobj@design)[length(as.character(deobj@design))]
  set(cD, i=NULL, j=grp, factor(cD[[grp]], ordered=TRUE, levels=unique(as.character(cD[[grp]]))))
  
  reslr <- results(deobj, independentFiltering = params$filterBaseMean, alpha=params$pcutoff)[, c('baseMean', 'pvalue', 'padj')] 
  ## FC is taken from just one of the pairwise coefficients, just to maintain output format. It is not interpretable with a global p-value...
  
  reslr <- data.table(name = rownames(reslr), as.data.frame(reslr))
  reslr[, mlog10p := -log10(padj)]
  setorder(reslr, -mlog10p, na.last=TRUE)
  reslr[, sig := padj <= params$pcutoff]
  reslr[is.na(sig), sig := FALSE]
  top <- head(reslr[, name], params$ntop)
  reslr[, istop := name %in% top]
  
  plr <- ggplot(NULL, aes(x=baseMean, y=mlog10p, colour=(padj < params$pcutoff), label=name)) +
    geom_point(data=reslr[(!istop) & !is.na(padj), ], shape=16, alpha=0.6) +
    geom_point(data=reslr[(istop), ], colour='red', shape=16, alpha=0.6) +
    geom_text_repel(data=reslr[(istop), ], size=rel(2.5),  colour="red",
                            segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=1, force_pull=1) +
    scale_x_log10() +
    scale_colour_manual(values=c('black', 'blue')) +
    annotation_logticks(sides='b') +
    labs(title=paste('LR [', paste(deobj@design, collapse=' '), '] against [', params$reducedFormula, ']'))
  
  print(plr)
}
```

### Expressions

Below are the per-condition expressions of the `r params$ntop` most significant features.

```{r DEg_x, fig.height=2, fig.width=7}
if (!is.null(params$reducedFormula)) {
  reslr <- merge(reslr, data.table(name=rownames(tpm), tpm), by='name')
  reslr <- melt(reslr, id.vars=c('name', 'baseMean', 'pvalue', 'padj', 'mlog10p', 'sig', 'istop'), value.name='Expression', variable.name='Sample')
  reslr <- merge(reslr, cD[, c('Sample', grp), with=FALSE], by='Sample', all.x=TRUE)
  set(reslr, i=NULL, j=grp, factor(reslr[[grp]], ordered=TRUE, levels=unique(as.character(cD[[grp]]))))
  
  setorder(reslr, -mlog10p, na.last=TRUE)
  topreslr <- head(unique(reslr$name), params$ntop)
  setkey(reslr, name)
  
  lplr2 <- lapply(topreslr, function(x){
    # x <- 'Parp8'
    ggplot(reslr[x, ], aes_string(x='Expression', y=grp, fill=grp)) +
      facet_wrap(~ name, ncol=1) +
      geom_boxplot() +
      geom_point() +
      scale_x_continuous(limits=c(0 , NA)) +
      labs(x=colsuffix) +
      theme(legend.position='none')
    })
  
  print(lplr2)
  
  
  # FCs
  reslr[, MeanXPR := mean(Expression), by=c('name', grp)]
  subres <- unique(reslr[, c('name', grp, 'MeanXPR'), with=FALSE])
  setorderv(subres, c('name', grp))
  subres[, lagMX := data.table::shift(MeanXPR, type='lag', n=1), by='name']
  subres[, FC := MeanXPR / lagMX, by='name']
  subres[FC > 1, FCtext := '+']
  subres[FC < 1, FCtext := '-']
  subres[FC == 1, FCtext := '='] # unlikely
  subres[is.na(FC), FCtext := '.']  # start time
  subres[, timecourse := paste(FCtext, collapse=''), by='name']
  
  reslr <- merge(reslr, subres[, c('name', grp, 'FC', 'timecourse'), with=FALSE], by=c('name', grp), all.x=TRUE)

} else {
  cat("Skipped.\n")
}
```

### Expression heatmap

Heatmap of the top hits from the LR test.

```{r dexplr, fig.height=22, fig.width=10}
# Counts
matlr <- tpm[topreslr, ]

# Custer row and columns
cfitlr <- hclust(dist(scale(t(matlr), center=TRUE))) # cluster columns
rfitlr <- hclust(dist(scale(matlr, center=FALSE)))    # cluster rows
cnlr <- colnames(matlr)[cfitlr$order]
rnlr <- rownames(matlr)[rfitlr$order]

# Custer row and columns
lrhitdf <- as.data.table(matlr)
lrhitdf[, Feature := rownames(matlr)]
lrhitdf <- melt(lrhitdf, value.name = "RPM", variable.name = "Sample", id.vars = "Feature")
lrhitdf[, Feature := ordered(Feature, levels=rnlr)]
lrhitdf[, Sample := ordered(Sample, levels=cnlr)]

plrexp <- ggplot(lrhitdf, aes(y=Feature, x=Sample, fill=log10(RPM))) +
  geom_tile() +
  scale_fill_gradient(high="gold", low="black", na.value='gray50', paste('log10', colsuffix)) +
  labs(y='', x='') +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5, size=rel(1)),
        axis.text.y = element_text(size=rel(0.6)),
        panel.grid = element_blank())

print(plrexp)
```

## Pairwise

Using the Wald test to obtain shrunken logFC estimates for individual pairwise comparisons.

```{r DE}
resall <- list()

# Build model
deobj <- DESeq(params$dds, test='Wald')

## Function
do_de_plots <- function(contrast, dds = deobj, rpms = tpm, regcnt=vstmat, ntop = params$ntop, addPrefix = params$longlabel,
                        pcutoff = params$pcutoff, lfcthreshold = params$lfcthreshold, filterBM=params$filterBaseMean, 
                        prefix=params$prefix, PMtype=colsuffix, rlog=params$rlog){
  # contrast <-  params$comparisons[[1]]
  # dds = deobj; rpms = tpm; ntop = params$ntop; addPrefix = params$longlabel; pcutoff = params$pcutoff; lfcthreshold = params$lfcthreshold; filterBM=params$filterBaseMean; prefix=params$prefix; PMtype=colsuffix; rlog=params$rlog; regcnt=vstmat
  highlight <- c("non-significant", "significant, FC low", "significant", paste("significant, top", params$ntop))
  hlcol <- c("grey50", "black", "blue", "red")
  names(hlcol) <- highlight
  ctrname <- paste0(contrast[1], '_', contrast[2], '_vs_', contrast[3])
  
  # Get DE for given contrast
  lfc <- results(dds, contrast=contrast, independentFiltering = filterBM, alpha=pcutoff)
  shrink <- lfcShrink(dds, contrast=contrast, type='ashr')
  lfc <- cbind(data.table(name=rownames(lfc)), as.data.table(lfc))
  shrink <- cbind(data.table(name=rownames(shrink)), as.data.table(shrink))
  
  # Precompute useful conversions
  lfc[, FC := 2 ^ log2FoldChange]
  lfc[, mlog10p := -log10(padj)]
  shrink[, mlog10p := -log10(padj)] 
  shrink[, absl2fc := abs(log2FoldChange)]
  
  # Combine shrunken and non-shrunken LFC tables for output, minus identical columns
  outtab <- merge(lfc, 
                  shrink[, ! names(shrink) %in% c('baseMean', 'pvalue'), with=FALSE], by="name", all=TRUE, suffixes=c('', '.shrink') )
  
  
  ## Home-brewed selection of top hits to highlight, by eucledian distance from origin.
  # It mostly works sensibly enough, but the selection should not be taken as gospel.
  
  # Thresholds.
  outtab[, meetthresh := !is.na(padj) & absl2fc >= lfcthreshold & padj < pcutoff]
  
  # Down-weight mlog10p for a more balanced selection not dominated by p value.
  ppen <- max(outtab$mlog10p, na.rm=TRUE) / max(outtab$absl2fc, na.rm=TRUE)  # "penalty" factor determined by axes ranges
  outtab[, dist := sqrt((mlog10p / ppen) ^ 2 + log2FoldChange.shrink ^ 2)]
  setorder(outtab, -dist, -absl2fc, -mlog10p, na.last = TRUE)
  
  # Selection helpers
  outtab[, istop := FALSE]
  outtab[(meetthresh), row := 1:.N]
  outtab[meetthresh & row <= ntop, istop := TRUE]  # The top N hits, but they must first actually be hits.
  outtab[, dist := NULL] [, absl2fc := NULL] [, row := NULL]  # they did their job
  outtab[, category := highlight[1]]
  outtab[!is.na(padj.shrink) & padj.shrink < params$pcutoff & !meetthresh, category := highlight[2]]
  outtab[meetthresh & !istop, category := highlight[3]]
  outtab[(istop), category := highlight[4]]
  outtab[, category := factor(category, ordered=TRUE, levels=highlight)]
  
  # Filter out the uninteresting points, to make it lightweight and ggplotly-friendly
  subfc <- outtab[(meetthresh), ]
  # Handle freak cases.
  if (nrow(subfc) <= ntop) {
    subfc <- outtab[abs(log2FoldChange) >= 0.5 & padj < 0.1, ] 
    # Relax thresholds, so there's more context to display in the interactive volcano.
  }
  if (nrow(subfc) < ntop) {
    subfc <- outtab[mlog10p > 0.1, ]
    # Scrape the bottom of the barrel.
  }
  if (nrow(subfc) < ntop) {
    subfc <- head(outtab, n=ntop)
    # Remove thresholds, If subfc is empty, the code breaks. 
    # It's too much hassle to code alternatives for all the places subfc is used.
  }
  
  ## Volcanos
  
  # Static image.
  pv1 <- ggplot(outtab, 
                aes(x=log2FoldChange, y=mlog10p, colour=istop, label=name)) + 
            geom_vline(xintercept = lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_vline(xintercept = -lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_hline(yintercept = -log10(pcutoff), linetype="dashed",  colour="steelblue1") + 
            geom_point(alpha=0.5) +
            geom_text_repel(data=outtab[(istop), ], size=rel(2.5),  colour="red",
                            segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=1, force_pull=1) +
            scale_colour_manual(values=c("black", "red")) +
            labs(x='log2( FC )', y='-log10( Padj )', title=ctrname) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  pv2 <- ggplot(outtab, 
                aes(x=log2FoldChange.shrink, y=mlog10p.shrink, colour=istop, label=name)) + 
            geom_vline(xintercept = lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_vline(xintercept = -lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_hline(yintercept = -log10(pcutoff), linetype="dashed",  colour="steelblue1") + 
            geom_point(alpha=0.5) +
            geom_text_repel(data=outtab[(istop), ], size=rel(2.5), colour="red",
                            segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=1, force_pull=1) +
            scale_colour_manual(values=c("black", "red")) +
            labs(x='log2( shrunken FC )', y='-log10( Padj )', title=ctrname) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  # Lighter image for interactive plotly. Only points that pass thresholds.
  pvly <- ggplot(subfc, 
                aes(x=log2FoldChange, y=mlog10p, label=name, colour=istop)) + 
            geom_vline(xintercept = lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_vline(xintercept = -lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_hline(yintercept = -log10(pcutoff), linetype="dotted",  colour="steelblue1") + 
            geom_point(alpha=0.5) +
            scale_colour_manual(values=c("black", "red")) +
            labs(x='log2( shrunken FC )', y='-log10( Padj )', title=ctrname) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  ## MA
  
  # Static image.
  pma1 <- ggplot(NULL, 
                aes(x=baseMean, y=log2FoldChange, label=name)) + 
            geom_hline(yintercept = 0,  colour="black") + 
            geom_point(data=outtab[padj >= pcutoff, ], colour='grey50', alpha=0.4, size=rel(0.8)) +
            geom_point(data=outtab[padj < pcutoff, ], colour='black', alpha=0.7) +
            geom_point(data=outtab[name %in% subfc[(istop), name], ], colour='red') +
            geom_hline(yintercept = lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_hline(yintercept = -lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_text_repel(data=outtab[(istop), ], colour="red", size=rel(2.5), segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=1, force_pull=1) +
            scale_x_log10() +
            annotation_logticks(base=10, sides='b') +
            labs(y='log2( FC )', y='baseMean', title=ctrname) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  pma2 <- ggplot(NULL, 
                aes(x=baseMean, y=log2FoldChange.shrink, label=name, shape= istop)) + 
            geom_hline(yintercept = 0,  colour="black") + 
            geom_point(data=outtab[padj >= pcutoff, ], colour='grey50', alpha=0.4, size=rel(0.8)) +
            geom_point(data=outtab[padj < pcutoff, ], colour='black', alpha=0.7) +
            geom_point(data=outtab[(istop), ], colour='red') +
            geom_hline(yintercept = lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_hline(yintercept = -lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_text_repel(data=outtab[name %in% subfc[(istop), name],], colour="red", size=rel(2.5), segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=1, force_pull=1) +
            scale_x_log10() +
            annotation_logticks(base=10, sides='b') +
            labs(y='log2( shrunken FC )', y='baseMean', title=ctrname) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  # Lighter image for interactive plotly. Only points that pass thresholds.
  pmaly <- ggplot(subfc, 
                aes(x=log10(baseMean), y=log2FoldChange, label=name, colour=istop)) + 
            geom_hline(yintercept = 0,  colour="grey50") + 
            geom_point(alpha=0.5) +
            geom_hline(yintercept = lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_hline(yintercept = -lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            scale_colour_manual(values=c("black", "red")) +
            labs(y='log2( FC )', y='log10( Mean )', title=ctrname) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  ## Expression heatmap of ntop genes that meet thresholds
  
  # Get the counts for the relevant samples only
  cD <- colData(dds)
  refs <- rownames(cD)[cD[, contrast[1]] == contrast[3]]
  treats <- rownames(cD)[cD[, contrast[1]] == contrast[2]]
  selcnt <- rpms[head(subfc$name, n=ntop), ]
  selvst <- regcnt[head(subfc$name, n=ntop), ]
  
  if (is.null(dim(selcnt))) {
    # if there is only one hit
    selvst <- as.data.frame( c(as.list(selvst[c(refs, treats)]), list(name=subfc$name)) )
    selvst$type <- ifelse(rlog, "rlog_count", "VST_count")
    selcnt <- as.data.frame( c(as.list(selcnt[c(refs, treats)]), list(name=subfc$name)) )
    selcnt$type <- PMtype
    # selcnt <- rbind(selcnt, selvst)
    selcnt <- melt(selcnt, id.vars="name", variable.name="sample", value.name=PMtype)
    selvst <- melt(selvst, id.vars="name", variable.name="sample", value.name=ifelse(rlog, "rlog_count", "VST_count"))
    # rn <- subfc$name
  } else {
    selcnt <- selcnt[, c(refs, treats)]
    selvst <- selvst[, c(refs, treats)]
    
    # Cluster row and columns
    cfit <- hclust(dist(scale(t(selvst), center=TRUE))) # cluster columns
    rfit <- hclust(dist(scale(selvst, center=FALSE)))    # cluster rows
    selcnt <- selcnt[rfit$order, cfit$order]
    selvst <- selvst[rfit$order, cfit$order]
    cn <- colnames(selvst)
    rn <- rownames(selvst)
    
    # Tidy
    selcnt <- as.data.table(cbind(data.table(name=rownames(selcnt)), as.data.frame(selcnt)))
    selcnt[, name := factor(name, ordered=TRUE, levels=rn)]
    selcnt[, type := PMtype]
    selvst <- as.data.table(cbind(data.table(name=rownames(selvst)), as.data.frame(selvst)))
    selvst[, name := factor(name, ordered=TRUE, levels=rn)]
    selvst[, type := ifelse(rlog, "rlog_count", "VST_count")]
    # selcnt <- rbind(selcnt, selvst)
    selcnt <- melt(selcnt, id.vars=c("name", "type"), variable.name="sample", value.name=PMtype)
    selcnt[, sample := factor(sample, ordered=TRUE, levels=cn)]
    selvst <- melt(selvst, id.vars=c("name", "type"), variable.name="sample", value.name=ifelse(rlog, "rlog_count", "VST_count"))
    selvst[, sample := factor(sample, ordered=TRUE, levels=cn)]
  }
  
  ph1 <- ggplot(selcnt, aes(x=sample, y=name, fill=log10(selcnt[["TPM"]]))) +
            geom_tile() +
            # facet_grid(. ~ type) +
            scale_fill_gradient(high="yellow2", low="darkgreen", na.value = "black", name="log10(TPM)") +
            labs(title=ctrname) +
            theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5),
                  panel.grid = element_blank())
  
  ph2 <- ggplot(selvst, aes_string(x="sample", y="name", fill=ifelse(rlog, "rlog_count", "VST_count"))) +
            geom_tile() +
            # facet_grid(. ~ type) +
            scale_fill_gradient(high="yellow2", low="darkgreen", na.value = "black") +
            labs(title=ctrname) +
            theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5),
                  panel.grid = element_blank())
  
  ## Expression scatters
  
  # Add expression
  
  cnt <- merge( data.table(name = rownames(counts(dds)),
                           # counts(dds)[outtab$name, c(refs, treats), drop=FALSE],
                           refMean = rowMeans(counts(dds)[outtab$name, refs, drop=FALSE]),
                           treatMean = rowMeans(counts(dds)[outtab$name, treats, drop=FALSE]),
                           maxCount = rowMaxs(counts(dds)[outtab$name, c(refs, treats), drop=FALSE]),
                           refStDev = sqrt(rowVars(counts(dds)[outtab$name, refs, drop=FALSE])),
                           treatStDev = sqrt(rowVars(counts(dds)[outtab$name, treats, drop=FALSE])) ),
                data.table(name=rownames(rpms), 
                           # rpms[, c(refs, treats), drop=FALSE],
                           refMeanTPM = rowMeans(rpms[, refs]),
                           treatMeanTPM = rowMeans(rpms[, treats]),
                           maxScaledCount = rowMaxs(rpms[, c(refs, treats )]) ),
                all=TRUE, by="name" )
  
  outtab <-merge(outtab,
                 cnt,
                 all=TRUE, by="name")
  
 
  # Increment the 0s so they survive the log-transformation, but in a way they don't mix with non-zero data.
  # If data has been pre-filtered with minMean, there should be no remaining zeros.
  zeros <- min(outtab[refMeanTPM > 0, refMeanTPM], outtab[treatMeanTPM > 0, treatMeanTPM]) / 10
  
  pe1 <- ggplot(NULL, aes(x=refMeanTPM + zeros, y=treatMeanTPM + zeros, label=name, colour=category)) +
      geom_abline(intercept = 0, slope = 1, colour='black') +
      geom_point(data=outtab[category == highlight[1], ], alpha=0.4, size=rel(0.8)) +
      geom_point(data=outtab[category == highlight[2], ], alpha=0.7, size=rel(0.8)) +
      geom_point(data=outtab[category == highlight[3], ], alpha=0.7) +
      geom_point(data=outtab[category == highlight[4], ]) +
      geom_label_repel(data=outtab[category == highlight[4], ], size=rel(2.5), colour="red",
                       segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=10, force_pull=5) +
      scale_x_log10() + 
      scale_y_log10() +
      scale_colour_manual(values=hlcol) +
      annotation_logticks(base=10, sides='lrtb') +
      labs(title=ctrname, x=paste('reference Mean', PMtype), y=paste('treatment Mean', PMtype)) +
      theme(panel.grid.minor = element_blank())
  
  pe1ly <- ggplot(NULL, aes(x=refMeanTPM + zeros, y=treatMeanTPM, label=name, colour=category)) +
      geom_abline(intercept = 0, slope = 1, colour='black') +
      geom_point(data=outtab[category == highlight[3], ], alpha=0.7) +
      geom_point(data=outtab[category == highlight[4], ]) +
      scale_x_log10() + 
      scale_y_log10() +
      scale_colour_manual(values=hlcol) +
      labs(title=ctrname, x=paste('reference Mean', PMtype), y=paste('treatment Mean', PMtype)) +
      theme(legend.position = "none", panel.grid.minor = element_blank()) 
  
  pe2 <- ggplot(NULL, aes(x=refMeanTPM + zeros, y=refStDev / (refMeanTPM + zeros), label=name, colour=category)) +
      geom_point(data=outtab[category == highlight[1], ], alpha=0.4, size=0.8) +
      geom_point(data=outtab[category == highlight[2], ], alpha=0.7, size=0.8) +
      geom_point(data=outtab[category == highlight[3], ], alpha=0.7) +
      geom_point(data=outtab[category == highlight[4], ]) +
      geom_label_repel(data=outtab[category == highlight[4], ], size=rel(2.5), colour="red",
                       segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=10, force_pull=5) +
      scale_x_log10() + 
      scale_y_log10() +
      scale_colour_manual(values=hlcol) +
      annotation_logticks(base=10, sides='lrtb') +
      labs(title=ctrname, x=paste('reference Mean', PMtype), y='reference Variation Coeff.') +
      theme(panel.grid.minor = element_blank()) 
  
  pe3 <- ggplot(NULL, aes(x=treatMeanTPM + zeros, y=treatStDev / (treatMeanTPM + zeros), label=name, colour=category)) +
      geom_point(data=outtab[category == highlight[1], ], alpha=0.4, size=0.8) +
      geom_point(data=outtab[category == highlight[2], ], alpha=0.7, size=0.8) +
      geom_point(data=outtab[category == highlight[3], ], alpha=0.7) +
      geom_point(data=outtab[category == highlight[4], ]) +
      geom_label_repel(data=outtab[category == highlight[4], ], size=rel(2.5), colour="red",
                       segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=10, force_pull=5) +
      scale_x_log10() + 
      scale_y_log10() +
      scale_colour_manual(values=hlcol) +
      annotation_logticks(base=10, sides='lrtb') +
      labs(title=ctrname, x=paste('treatment Mean', PMtype), y='treatment Variation Coeff.') +
      theme(panel.grid.minor = element_blank()) 
  
  ## Table pt2
  
  hashits <- any(outtab[, meetthresh], na.rm=TRUE)
  setnames(outtab, sub('TPM|RPM', PMtype, names(outtab)))
  
  # Drop columns I don't need
  keep <- c("name", "baseMean", "FC", "pvalue", "padj",
              names(outtab)[grepl("refMean", names(outtab))], names(outtab)[grepl("treatMean", names(outtab))], # avoid explicitly handling TPM vs RPM
              "log2FoldChange", "mlog10p", "log2FoldChange.shrink", "maxCount", "maxScaledCount")
  outtab <- outtab[, keep, with=FALSE]
  
  virgin <- NULL
  if (addPrefix) {
    # Pristine copy, without prefixes.
    virgin <- copy(outtab)
    
    # Prepare column names for merging the files later
    prefix <- paste(prefix,
                     # paste(sub('[^A-Za-z0-9_\\-.+~]', '-', design(dds), perl=TRUE), collapse=''),
                     ctrname, sep='.')
    # # Add prefix
    # setnames(outtab,
    #          c(names(outtab)[1],              # keep uniform name across tables for the joining key
    #            paste(prefix,
    #                  names(outtab)[2:length(outtab)], sep='.') ) )
    
    # Add as suffix instead. Makes life easier in spotfire
    setnames(outtab, c(names(outtab)[1],      # keep uniform name across tables for use as joining key
                       paste(names(outtab)[2:length(outtab)],  prefix, sep='.')) )
  
  }
  
  return(list(contrast=ctrname, 
              pv1=pv1, pv2=pv2, #pvly=ggplotly(pvly, dynamicTicks = TRUE),
              pma1=pma1, pma2=pma2, #pmaly=ggplotly(pmaly, dynamicTicks = TRUE),
              pe1=pe1, pe2=pe2, pe3=pe3, #pe1ly=ggplotly(pe1ly, dynamicTicks = TRUE),
              ph1=ph1, ph2=ph2, 
              tophits=rn, hashits=hashits,
              outtab=outtab, virgin=virgin))
}
##

# Contrast against the assigned reference
if (!is.null(params$comparisons)) {
  resall <- lapply(params$comparisons, function(contrast) {
    # contrast <-  params$comparisons[[1]]
    message('CONTRAST:', paste0(contrast[1], ' : ', contrast[2], ' vs. ', contrast[3]))
    do_de_plots(contrast) 
  })

  names(resall) <- vapply(resall, function(x) { x$contrast }, character(1))
}
```

### Results

IMPORTANT: In the name of each comparison, the condition used as **"reference" is always shown to the right** of the `vs` in the name, whereas the condition used as **"treatment" is always shown on the left** of the `vs`.

```{r expov, warning=FALSE, fig.height=9, fig.width=10}
for (res in resall) {
  # res <- resall[[1]]
  
  # Are there any hits?
  # message(paste(res$contrast, res$hashits))
  if (!res$hashits) {
    message(paste("No hits meeting criteria in ", res$contrast,"! Listing outermost points instead."))
  }

  # Hit list
  ##########
  
  cat("\nCONTRAST: ")
  cat(res[["contrast"]])
  cat("\n\nTop hits (or, if no hits exist, nearest to being hits):\n")
  cat(as.character(res[["tophits"]]))
  cat("\n")
  
  
  # Plots
  ################
  
  print(res[["pv1"]])
  print(res[["pe1"]])
  # print( (res[["pe2"]] + theme(legend.position='none')) | (res[["pe3"]] + theme(legend.position='none')))
  # print(res[["pma1"]])
  print(res[["ph2"]])
}
```


<!-- ### Interactive filtered Volcanos and Expressions -->

<!-- All genes that do not meet both the fold-change threshold and the significance cutoff are removed completely from these plots to reduce visual clutter and to keep the report file size practical. -->

<!-- ```{r mas, fig.height=6, fig.width=7, warning=FALSE} -->
<!-- # These plots are not faceted, so need less width. -->

<!-- ly <- lapply(resall, function(res) { -->
<!--   # res <- resall[[1]] -->
<!--   # list(res[["pvly"]], res[["pe1ly"]]) -->
<!--   res[["pvly"]] -->
<!-- }) -->

<!-- htmltools::tagList(ly) -->
<!-- ``` -->

### Expression heatmap

Heatmap of all the top hits from all the pairwise comparisons in this report.

```{r dexp, fig.height=22, fig.width=10}
if (!is.null(params$comparisons)) {
  # Collect all the top50s
  allhits <- Reduce(union, lapply(resall, function(res) {
    return(res[["tophits"]])
  }))
  
  # Counts
  mat1 <- vstmat[allhits, ]
  mat2 <- tpm[allhits, ]
  
  # Custer row and columns
  cfit <- hclust(dist(scale(t(mat1), center=TRUE))) # cluster columns
  rfit <- hclust(dist(scale(mat1, center=FALSE)))    # cluster rows
  cn <- colnames(mat1)[cfit$order]
  rn <- rownames(mat1)[rfit$order]
  
  allhitdf <- as.data.table(mat2)
  allhitdf[, Feature := rownames(mat2)]
  allhitdf <- melt(allhitdf, value.name = "RPM", variable.name = "Sample", id.vars = "Feature")
  allhitdf[, Feature := ordered(Feature, levels=rn)]
  allhitdf[, Sample := ordered(Sample, levels=cn)]
  
  pallexp <- ggplot(allhitdf, aes(y=Feature, x=Sample, fill=log10(RPM))) +
    geom_tile() +
    scale_fill_gradient(high="gold", low="black", na.value='gray50', paste('log10', colsuffix)) +
    labs(y='', x='') +
    theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5, size=rel(1)),
          axis.text.y = element_text(size=rel(0.6)),
          panel.grid = element_blank())
  
  allhitdf <- as.data.table(mat1)
  allhitdf[, Feature := rownames(mat1)]
  allhitdf <- melt(allhitdf, value.name = ifelse(params$rlog, "rlog_count", "VST_count"), 
                   variable.name = "Sample", id.vars = "Feature")
  allhitdf[, Feature := ordered(Feature, levels=rn)]
  allhitdf[, Sample := ordered(Sample, levels=cn)]
  
  pallvst <- ggplot(allhitdf, 
                    aes_string(y="Feature", x="Sample", fill=ifelse(params$rlog, "rlog_count", "VST_count"))) +
    geom_tile() +
    scale_fill_gradient(high="gold", low="black", na.value='gray50') +
    labs(y='', x='') +
    theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5, size=rel(1)),
          axis.text.y = element_text(size=rel(0.6)),
          panel.grid = element_blank())
  
  print(pallvst)
  # print(pallexp)
}
```


# Files out

## Tables

```{r csv}
if (!is.null(params$reducedFormula)) {
  fwrite(reslr,
         file = file.path(params$baseDir,
                          params$resultsDir,
                          paste(params$prefix, paste0('LRT_', grp), 'deseq2.tsv', sep='.')),
           sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
}

if (!is.null(params$comparisons)) {
  for (res in resall) {
    # Drop columns I don't need
    fwrite(res$outtab,
           file = file.path(params$baseDir,
                            params$resultsDir,
                            paste(params$prefix, res$contrast, 'deseq2.tsv', sep='.')),
           sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
    if (params$longlabel)
      fwrite(res$virgin,
           file = file.path(params$baseDir,
                            params$resultsDir,
                            paste(params$prefix, res$contrast, 'deseq2.nolab.tsv', sep='.')),
           sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
  }
}
```

<!-- ## Plots to PDF -->

<!-- ```{r pdf} -->
<!-- pdf(file.path(params$baseDir,  -->
<!--               params$resultsDir,  -->
<!--               sub('html$', 'pdf', params$selfname)), -->
<!--     title=paste(params$prefix, paste(sub('[^A-Za-z0-9_\\-.+~]', '-', design(deobj), perl=TRUE), collapse=''), 'deseq2', sep='.'), -->
<!--     width=15, height=15) -->

<!-- # PCA plots -->
<!-- for (x in names(cD)) { -->
<!--   print( plotPCA(vst, intgroup=x) + labs(title=x) ) -->
<!-- } -->

<!-- # Correlation plots -->
<!-- # print(corels1p[['sfrnc']] + labs(substitle=colsuffix)) -->
<!-- print(corels1s[['sdrc']] + labs(substitle=colsuffix)) -->
<!-- print(corels2p[['sfrnc']] + labs(substitle='regularized counts')) -->
<!-- # print(corels2s[['sdrc']] + labs(substitle='regularized counts')) -->

<!-- # DE plots -->
<!-- for (res in resall){ -->
<!--   # Static plots -->
<!--   print(res[["pv1"]]) -->
<!--   # print(res[["pv2"]]) -->
<!--   print(res[["pe1"]]) -->
<!--   # print(res[["pe2"]]) -->
<!--   # print(res[["pe3"]]) -->
<!--   print(res[["pma1"]]) -->
<!--   # print(res[["pma2"]]) -->
<!--   # print(res[["ph1"]]) -->
<!--   print(res[["ph2"]]) -->
<!-- } -->
<!-- print(pallexp) -->
<!-- # print(pallvst) -->

<!-- dev.off() -->
<!-- ``` -->



# Session info

```{r}
sessionInfo()
```
