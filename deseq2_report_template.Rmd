---
title: "DE Report : EFpost"
author: "Kimon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    code_folding: hide
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE)
```

# Setup

```{r libraries}
library(DESeq2)
library(data.table)
library(ggplot2)
library(plotly)
library(htmltools)
library(topGO)
library(org.Mm.eg.db)
```

```{r parameters}
theme_set(theme_bw())

ntop = 50
pcutoff <- 0.001
lfcthreshold <- 1
ppen = 5           # Scale-down factor for -log10p when calculating point distances from the origin.

dds <- readRDS('/Volumes/groups/zuber/zubarchive/USERS/Kimon/markus/M9179_quantseq/process/DE_wald/EFpost/gene_deseq2.RDS')

# xref <- NULL
xref <- fread('/Volumes/groups/zuber/zubarchive/USERS/Kimon/markus/M9179_quantseq/aux/xref_mm_genes.txt')
```

```{r preprocess}
cat(paste("P cut-off:", pcutoff))
cat(paste("log2FC threshold:", lfcthreshold))
cat(paste("max N hits to highlight and list:", ntop))

# Assume first column of xref is key
if (!is.null(xref)){
  setkeyv(xref, cols=names(xref)[1])
}
# Mash together the alternative IDs
xref[, mashed := apply(xref, 1, function(x){paste(rev(x), collapse=':')})]

# Contrasts.
coeffs <- resultsNames(dds)[resultsNames(dds) != "Intercept"]

# Variance stabisized counts
vstmat <- assay(vst(dds, blind=FALSE))
```

```{r functions}
# DE
do_de_plots <- function(dds, contrast, xref, ntop, pcutoff=0.001, lfcthreshold=1){
  # Get DE for given contrast
  lfc <- results(dds, name=contrast)
  lfc <- cbind(data.table(name=rownames(lfc)), as.data.table(lfc))
  lfc[, mlog10p := -log10(padj)] [, type := "raw LFC"]
  shrink <- lfcShrink(dds, coef=contrast, type='apeglm')
  shrink <- cbind(data.table(name=rownames(shrink)), as.data.table(shrink))
  shrink[, comboID := xref[shrink$name, mashed]]
  shrink[, mlog10p := -log10(padj)] [, type := "shrunken LFC"] [, absl2fc := abs(log2FoldChange)]
  shrink[, meetthresh := abs(log2FoldChange) >= lfcthreshold & padj < pcutoff]
  shrink[complete.cases(shrink), dist := sqrt((mlog10p/ppen)^2 + log2FoldChange^2)]  # logp is usually much bigger than logfc, so down-weight it a little
  setorder(shrink, -dist, -mlog10p, -absl2fc, na.last = TRUE)
  shrink[, istop := FALSE]
  shrink[1:ntop, istop := meetthresh]  # The top N hits, must first be hits.
  
  # if (!any(shrink$meetthresh)) {
  #   warning(paste("WARNING -", contrast, "- No points meet the L2FC and Padj criteria!"))
  # }
  
  # Filter out the uninteresting points, to make it lightweight and ggplotly-friendly
  subfc <- shrink[(meetthresh), ]
  # Handle freak cases.
  if (nrow(subfc) <= ntop) {
    subfc <- shrink[abs(log2FoldChange) >= 0.5 & padj < 0.1, ] 
    # Relax thresholds, so there's more context to display in the interactive volcano.
  }
  if (nrow(subfc) < ntop) {
    subfc <- shrink[mlog10p > 0.1, ]
    # Scrape the bottom of the barel.
  }
  if (nrow(subfc) < ntop) {
    subfc <- head(shrink, n=ntop)
    # Remove thresholds, If subfc is empty, the code breaks. 
    # It's too much hassle to code alternatives for all the places subfc is used.
  }
  
  # Volcanos
  
  pv1 <- ggplot(rbind(lfc, shrink, fill=TRUE), 
                aes(x=log2FoldChange, y=mlog10p, 
                    shape= name %in% subfc[(istop), name], 
                    colour=name %in% subfc[(istop), name])) + 
            facet_grid( . ~ type) +
            geom_point(size=0.8, alpha=0.5) +
            geom_vline(xintercept = lfcthreshold, linetype="dotted",  colour="steelblue") + 
            geom_vline(xintercept = -lfcthreshold, linetype="dotted",  colour="steelblue") + 
            geom_hline(yintercept = -log10(pcutoff), linetype="dotted",  colour="steelblue") + 
            scale_colour_manual(values=c("black", "magenta")) +
            scale_shape_manual(values=c(16, 17)) +
            labs(x='log2( FC )', y='-log10( Padj )', title=contrast) +
            theme(legend.position = "none", panel.grid = element_blank())
  pv2 <- ggplot(subfc, 
                aes(x=log2FoldChange, y=mlog10p, label=comboID)) + 
            geom_vline(xintercept = lfcthreshold, linetype="dotted",  colour="steelblue") + 
            geom_vline(xintercept = -lfcthreshold, linetype="dotted",  colour="steelblue") + 
            geom_hline(yintercept = -log10(pcutoff), linetype="dotted",  colour="steelblue") + 
            geom_point(size=0.8, alpha=0.5) +
            labs(x='', y='', title=contrast) + # Re-add the axis titles with plotly later, because ggplotly() loses them anyway
            theme(panel.grid = element_blank())
  
  # Expression of ntop genes that meet thresholds
  
  # Get the counts for the relevant samples only
  mM <- attr(dds, "modelMatrix")
  refs <- rownames(mM[apply(mM, 1, sum) == 1, , drop=FALSE])
  treats <- rownames(mM)[mM[, contrast] == 1]
  selvst <- assay(vst(dds, blind=FALSE))[head(subfc$name, n=ntop), ]
  selcnt <- log10(counts(dds)[head(subfc$name, n=ntop), ]) # Range too broad, dominated by few silly-high expression
  if (is.null(dim(selcnt))){ # if there is only one hit
    selvst <- as.data.frame( c(as.list(selvst[c(refs, treats)]), list(name=subfc$name)) )
    selcnt$type <- "log10(raw count)"
    selcnt <- as.data.frame( c(as.list(selcnt[c(refs, treats)]), list(name=subfc$name)) )
    selcnt$type <- "VST count"
    selcnt <- rbind(selcnt, selvst)
    selvst <- melt(selcnt, id.vars="name", variable.name="sample", value.name="count")
    rn <- subfc$name
  } else {
    selcnt <- selcnt[, c(refs, treats)]
    selvst <- selvst[, c(refs, treats)]
    # Custer row and columns
    cfit <- hclust(dist(scale(t(selvst), center=TRUE))) # cluster columns
    rfit <- hclust(dist(scale(selvst, center=FALSE)))    # cluster rows
    selcnt <- selcnt[rfit$order, cfit$order]
    selvst <- selvst[rfit$order, cfit$order]
    cn <- colnames(selvst)
    rn <- rownames(selvst)
    # Scale log(raw) to VST, so they can share the fill gradient.
    selcnt <- selcnt * (median(selvst) / median(selcnt))
    # Tidy
    selcnt <- as.data.table(cbind(data.table(name=rownames(selcnt)), as.data.frame(selcnt)))
    selcnt[, name := factor(name, ordered=TRUE, levels=rn)]
    selcnt[, type := "log10(raw count)"]
    selvst <- as.data.table(cbind(data.table(name=rownames(selvst)), as.data.frame(selvst)))
    selvst[, name := factor(name, ordered=TRUE, levels=rn)]
    selvst[, type := "VST count"]
    selcnt <- rbind(selcnt, selvst)
    selcnt <- melt(selcnt, id.vars=c("name", "type"), variable.name="sample", value.name="VST_count") 
    # I want the legend title to be VST even if scaled(log(raw)) are also included, because it makes sense as legend name since CST is the scaling reference
    selcnt[, sample := factor(sample, ordered=TRUE, levels=cn)]
  }
  selcnt$id <- xref[as.character(selcnt$name), mashed]
  selcnt[, id := factor(id, ordered=TRUE, levels=unique(id))]
  
  pe1 <- ggplot(selcnt, aes(x=sample, y=id, fill=VST_count)) +
            geom_tile() +
            facet_grid(. ~ type) +
            scale_fill_gradient(low="transparent", high="darkgreen", limits=c(0, max(selcnt$VST_count)), na.value = "transparent") +
            labs(title=contrast) +
            theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5),
                  panel.grid.major = element_blank())
  
  return(list(contrast=contrast, pv1=pv1, pv2=pv2, pe1=pe1, tophits=rn, shrunkLFC=shrink))
}

# Correlations
my_pairwise_internal_coords <- function(mat, method="pearson") {
  # Correlations
  cormat <- cor(mat, method=method)
  
  # Cluster
  hcfit <- hclust(dist(scale(cormat, center=TRUE)))
  cormat <- cormat[hcfit$order, hcfit$order]
  rn <- rownames(cormat)
  cormat2 <- cormat # Duplicate,
  
  # Delete diagonal half for the numeric labels. But keep the heatmap square, because pretty.
  for (r in 1:nrow(cormat)) {
    for (c in 1:ncol(cormat)) {
      if (c < r) {
        cormat[r, c] <- NA_real_
      }
    }
  }
  
  cormat <- as.data.table(t(cormat))
  cormat[, observation1 := factor(rn, ordered=TRUE, levels=rn)]
  cormat <- melt(cormat, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat[, observation2 := factor(observation2, ordered=TRUE, levels=rn)]
  cormat2 <- as.data.table(t(cormat2))
  cormat2[, observation1 := factor(rn, ordered=TRUE, levels=rn)]
  cormat2 <- melt(cormat2, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat2[, observation2 := factor(observation2, ordered=TRUE, levels=rn)]
  
  p <- ggplot(cormat2, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat, aes(label=round(Correlation, 2), colour=Correlation)) +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue", "blue", "darkblue", "black", "darkred", "red", "orange", "yellow"), na.value = "transparent" ) +
    scale_colour_gradientn(limits=c(-1, 1), colors=rep(c("black", "white", "white", "black"), each=3), guide="none") +
    labs(x='', y='') +
    theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5),
          panel.grid.major = element_blank() )
  return(p)
}

# GO enrichment
do_go <- function(de, db, ntop, onto){
  if (any(de$meetthresh)) {
    geneList <- factor(as.integer(de$meetthresh & de$istop))
    names(geneList) <- de$name
    
    GOdata <- new("topGOdata",
                  description = paste(onto, db), 
                  ontology = onto,
                  allGenes = geneList,
                  nodeSize = 10,
                  annot = annFUN.org,
                  mapping = db,
                  ID = "ensembl")
    resFish <- runTest(GOdata, algorithm = "classic", statistic = "fisher")
    allRes <- GenTable(GOdata, classicFisher = resFish, ranksOf = "classicFisher", topNodes = ntop)
    
    return(allRes[allRes$classicFisher < 0.05,])
  }
}
```


# Correlations
 
 Correlations of the samples, based on the raw and the Variance-Stabilisation-Transformed counts. In VST the counts are scaled such as to have the same amount of variance across all count magnitudes, effectively removing noise from the low counts.
 
```{r correlations, fig.height=7, fig.width=8}
# Correlation of raw counts
print(my_pairwise_internal_coords(counts(dds)) + labs(title="Sample correlations (raw counts)"))

# Variance stabilised counts
print(my_pairwise_internal_coords(vstmat) + labs(title="Sample correlations (VST counts)"))
```


# DE

The highlighted magenta triangles are the up to `r ntop` top hits out of all the points that meet the thresholds. This number limit is arbitrary. "Top-ness" of hits is ranked roughly based on their distance from the origin of the axes. Cross-referenced IDs, expression and GO term enrichment is provided for the top hits.

The interactive volcano plots include *all* the points that meet the thresholds are shown in the next subsection. There you can hover over points to see their ID, zoom, etc.

If a contrast does not have any hits that meet the thresholds defined at the beginning of this report, a warning message will indicate that there are no hits, there will be no highlighted points and no GO terms. The `r ntop` points farthest from the origin will still be listed in the table and shown in the interactive volcanoes to satisfy your curiosity.

```{r DE}
resall <- lapply(coeffs, function(contrast) {
  do_de_plots(dds, contrast, xref[, c(1, ncol(xref)), with=FALSE], ntop, pcutoff, lfcthreshold)
})
```

## Volcanoes

```{r volcano, fig.height=6, fig.width=12}
ly <- htmltools::tagList()
for (i in 1:length(resall)){
  # Volcanoes
  print(resall[[i]][["pv1"]])
  ly[[i]] <- as_widget(subplot( ggplotly(resall[[i]][["pv2"]], dynamicTicks = TRUE) %>% 
                                  layout(xaxis = list(title="-log10( Padj )"), 
                                         yaxis = list(title="log2( FC )")) ))
}
```

### Interactive filtered volcanoes

```{r interactive, fig.height=6, fig.width=6}
ly
```

## Top hits

```{r hits, fig.height=10, fig.width=8}
ly <- htmltools::tagList()

for (res  in resall){
  cat(res[["contrast"]])
  
  # Are there any hits?
  de <- res[['shrunkLFC']]
  if (!any(de$meetthresh)) {
    warning(paste("No hits meeting criteria in ", coeffs[i],"! Listing outermost points instead."))
  }
  
  # Hit expression
  print(res[["pe1"]])
  
  # Hit list
  if (is.null(xref)){
    print(res[["tophits"]])
  } else {
    print(xref[res[["tophits"]], -ncol(xref), with=FALSE])
  }
  
}
```

## Ontology term enrichment

```{r go}
for (res  in resall){
  # GO term enrichment
  print(paste(res[["contrast"]], "-- GO Biological Process"))
  go1 <- do_go(res[["shrunkLFC"]], 'org.Mm.eg', ntop, 'BP')
  print(go1)
  print(paste(res[["contrast"]], "-- GO Molecular Function"))
  go2 <- do_go(res[["shrunkLFC"]], 'org.Mm.eg', ntop, 'MF')
  print(go2)
  print(paste(res[["contrast"]], "-- GO Cellular Component"))
  go3 <- do_go(res[["shrunkLFC"]], 'org.Mm.eg', ntop, 'CC')
  print(go3)
}
```

# Session info

```{r}
sessionInfo()
```
