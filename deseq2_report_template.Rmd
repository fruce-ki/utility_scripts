---
title: "DE Quick View"
author: "Kimon Froussios"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float:
      collapsed: false
params:
  selfname: ""
  derds: "null.RDS"     # MUST be specified, DESeq2 Dataset object file (before model creation)
  prefix: ""
  resultsDir: "."
  baseDir: "."
  pcutoff: 0.05
  lfcthreshold: 1
  ntop: 50             # maximum number of hits to list
  minMean: 10          # Minimum sum of counts across samples per gene (already applied, just here for parameter documentation in the report)
  minSingle: 100
  filterBaseMean: True  # DESeq2 independent filtering
  reducedFormula: 'NULL'
  roundrobin: True      # do all-vs-all comparisons (for single-factor comparisons only). Otherwise only vs assigned reference condition.
  longlabel: false     # Prepend comparison info to standard column names.
  covars: NULL
  widths: NULL         # Feature lengths table.
  specnorm: NULL
  rlog: TRUE          # FALSE for VST instead
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE)
```


# Setup

```{r libraries}
library(DESeq2)
library(data.table)
library(ggplot2)
library(plotly)
library(htmltools)
library(patchwork)
library(ggrepel)
library(ggdendro)
library(DT)

# ggplot2 base theme
theme_set(theme_bw())

data.table::setDTthreads(1L)

options(scipen=2)

if (!is.null(params$reducedFormula)){
  if (params$reducedFormula == 'NULL') {
    params$reducedFormula <- NULL
  }
}
```

```{r preprocess}
# DESeq2 object set up with he relevant materials for this comparison formula
deobj <- readRDS(params$derds)

# Variance-regularized counts
if (params$rlog) {
  vstmat <- assay(rlog(deobj, blind = TRUE))
} else {
  vstmat <- assay(vst(deobj, blind=FALSE))
}

# TPM/RPM
normscale <- function(counts, featLens=NULL, specnorm=params$specnorm){
  if (!is.null(featLens)) {
    # Reorder/subset
    setkeyv(featLens, names(featLens)[1])
    featLens <- featLens[rownames(counts)]
    stopifnot(all(!is.na(featLens[, 2])))  # incomplete lengths
    # Scale by feature size
    TPMs <- sweep(counts, 1, featLens[[2]], `/`)
  }
  # Scale by sequencing depth
  if (!is.null(specnorm)) {
    colsums <- colSums(TPMs[!grepl(specnorm, rownames(TPMs), ignore.case=TRUE, perl=TRUE), ], na.rm=TRUE)  # MOUSE only!
  } else {
    colsums <- colSums(TPMs, na.rm=TRUE)
  }
  TPMs <- sweep(TPMs, 2, colsums, `/`) * 1e6
  
  return(TPMs)
}

tpm <- normscale(counts(deobj, normalized = FALSE, replaced = FALSE), params$widths)

if (is.null(params$widths)){
  message('Scaled counts to RPM.')
  colsuffix <- 'RPM'
#  colnames(tpm) <- paste0(colnames(tpm), '.RPM')
} else {
  message('Scaled counts to TPM.')
  colsuffix <- 'TPM'
#  colnames(tpm) <- paste0(colnames(tpm), '.TPM')
}


# Covariates relevant to this comparison
cD <- colData(deobj)[, 1:length(colData(deobj)), drop=FALSE]  # before model building there in no size factor as last column

cat(paste("Prepared input: ", params$derds))
cat(paste("Min required mean raw counts across relevant samples:", params$minMean))
cat(paste("Min required raw count in a single sample when the min mean is not met:", params$minSingle))
cat(paste("DESeq2 independent filtering:", params$filterBaseMean))
cat(paste("Significance level:", params$pcutoff))
cat(paste0("log2FC threshold: ", params$lfcthreshold, " , (i.e. ", round(2 ^ params$lfcthreshold, 2), "-fold change)"))
cat(paste("Max number of top hits to highlight:", params$ntop))
cat(paste("Round-robin comparisons between treatments:", params$roundrobin))
cat(paste("Variance regularized counts type: ", ifelse(params$rlog, "rlog2", "VST")))
cat(paste("Genes excluded from library size calculations (only affects TPM/RPM, does not affect DESeq2):", params$specnorm))

print( datatable(params$covars) )
```


# Correlations

```{r functionC}
# Correlations
my_pairwise_internal_corels <- function(mat, samples, method = "pearson", rds=NULL, txs=3, minMean=0, minSingle=0) {
  # mat <- vstmat; samples <- colnames(rpm)
  
  # Filter
  if (minMean != 0 | minSingle != 0) {
    mat <- mat[rowSums(mat >= minSingle) >= 1 | rowMeans(mat) >= minMean, ]
  } else {
    mat <- mat[rowSums(mat) > 0, ]
  }
  
  # Correlations
  cormat <- cor(mat, method=method)
  
  # Cluster
  hcfit <- hclust(dist(scale(cormat, center=TRUE)))
  rn <- rownames(cormat)
  
  # Make dendrogram. https://stackoverflow.com/questions/42047896/joining-a-dendrogram-and-a-heatmap
  dend <- as.dendrogram(hcfit)
  dend_data <- dendro_data(dend)
  # Setup the data, so that the axes are exchanged, instead of using coord_flip()
  segment_data <- with(
      segment(dend_data), 
      data.frame(x = y, y = x, xend = yend, yend = xend))
  # Use the dendrogram label data to position the sample labels
  sample_pos_table <- with(
      dend_data$labels, 
      data.frame(y_center = x, Sample = as.character(label), height = 1))
  # Limits for the vertical axes
  sample_axis_limits <- with(
      sample_pos_table, 
      c(min(y_center - 0.5 * height), max(y_center + 0.5 * height))
  ) + 0.1 * c(-1, 1) # extra spacing: 0.1
  # Dendrogram plot
  pd <- ggplot(segment_data) + 
    geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) + 
    scale_x_reverse(expand = c(0, 0.5),
                    position = "top") + 
    scale_y_continuous(position = "right",
                       breaks = sample_pos_table$y_center, 
                       labels = sample_pos_table$Sample, 
                       limits = sample_axis_limits, 
                       expand = c(0, 0)) + 
    labs(x = NULL, y = NULL) +
    theme_minimal() + 
    theme(panel.grid = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank())

  
  # Create duplicates for different plot styles
  cormat <- cormat[samples, samples]                    # Supplied order
  cormat2 <- cormat                                     # Duplicate in which to delete below the diagonal.
  cormat3 <- cormat[rn[hcfit$order], rn[hcfit$order]]   # Duplicate in clustered order.
  cormat4 <- cormat3                                    # Duplicate in clustered order in which to delete below the diagonal.
  # Delete below diagonal half for the numeric labels.
  for (r in 1:nrow(cormat2)) {
    for (c in 1:ncol(cormat2)) {
      if (c <= r) {
        cormat2[r, c] <- NA_real_
      }
    }
  }
  for (r in 1:nrow(cormat4)) {
    for (c in 1:ncol(cormat4)) {
      if (c <= r) {
        cormat4[r, c] <- NA_real_
      }
    }
  }
  
  # Restructure for plotting.
  rn <- rownames(cormat)
  cormat <- as.data.table(cormat)
  cormat[, observation1 := factor(rn, ordered=TRUE, levels=rn)]
  cormat <- melt(cormat, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat[, observation2 := factor(observation2, ordered=TRUE, levels=rn)]
  # cormat <- merge(cormat, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  rn2 <- rownames(cormat2)
  cormat2 <- as.data.table(cormat2)
  cormat2[, observation1 := factor(rn2, ordered=TRUE, levels=rn2)]
  cormat2 <- melt(cormat2, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat2[, observation2 := factor(observation2, ordered=TRUE, levels=rn2)]
  cormat2 <- cormat2[!is.na(Correlation)]
  # cormat2 <- merge(cormat2, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  rn3 <- rownames(cormat3)
  cormat3 <- as.data.table(cormat3)
  cormat3[, observation1 := factor(rn3, ordered=TRUE, levels=rn3)]
  cormat3 <- melt(cormat3, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat3[, observation2 := factor(observation2, ordered=TRUE, levels=rn3)]
  # cormat3 <- merge(cormat3, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  rn4 <- rownames(cormat4)
  cormat4 <- as.data.table(cormat4)
  cormat4[, observation1 := factor(rn3, ordered=TRUE, levels=rn4)]
  cormat4 <- melt(cormat4, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat4[, observation2 := factor(observation2, ordered=TRUE, levels=rn4)]
  cormat4 <- cormat4[!is.na(Correlation)]
  # cormat4 <- merge(cormat4, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  # Text colour switch for the dynamic range
  m <- min(cormat4$Correlation, na.rm=TRUE)
  M <- max(cormat4$Correlation, na.rm=TRUE)
  colourswitch <- c( m + 0.49 * (M-m),  m + 0.51 * (M-m) )
  
  
  # # Square. Custom order. No values. Full range.
  # p1 <- ggplot(cormat, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
  #   scale_x_discrete(position = "top") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Square. Custom order. No values. Dynamic range.
  # p1a <- ggplot(cormat, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
  #   scale_x_discrete(position = "top") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Triangle. Custom order. With values. Full range.
  # p2 <- ggplot(cormat2, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
  #   scale_x_discrete(position = "top") +
  #   scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
  #   scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Triangle. Custom order. With values. Dynamic range.
  # p2a <- ggplot(cormat2, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
  #   scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
  #   scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
  #   scale_x_discrete(position = "top") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  
  # Square. Custom order. With values. Full range.
  p12 <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat2, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Custom order. With values. Dyhamic range.
  p12a <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat2, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  
  # # Square. Clustered order. No values. Full range.
  # p3 <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
  #   scale_x_discrete(position = "top") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Square. Clustered order. No values. Dyhamic range.
  # p3a <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
  #   scale_x_discrete(position = "top") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Triangle. Clustered order. with values. Full range.
  # p4 <- ggplot(cormat4, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
  #   scale_x_discrete(position = "top") +
  #   scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
  #   scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Triangle. Clustered order. with values. Dyhamic range.
  # p4a <- ggplot(cormat4, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
  #   scale_x_discrete(position = "top") +
  #   scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
  #   scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  
  # Square. Clustered order. With values. Full range.
  p34 <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat4, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Clustered order. With values. Dyhamic range.
  p34a <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat4, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  out <- list(corr=dcast(cormat2, observation1 ~ observation2, value.var = "Correlation"),
              # sfrnc=p1, tfrnc=p2, sdrnc=p1a, tdrnc=p2a,
              frnc=p12, drnc=p12a,
              # sfrc=pd + p3, tfrc=p4, sdrc=pd + p3a, tdrc=p4a,
              frc=pd + p34 + plot_layout(ncol=2, widths=c(1,4)), 
              drc=pd + p34a + plot_layout(ncol=2, widths=c(1,4)))
  
  if (!is.null(rds)) {
    saveRDS(out, file = rds)
  }
  
  return(out)
}
```
 
Using TPM (RPM if no feature lengths were available) ensures that size effects do not influence correlation. VST counts adjust for the inflated variance of low count genes and often offer a clearer view less influenced by expression noise. 

The *Pearson* correlation coefficient between samples X and Y measures how much their observations can be represented as `Y = A * X`. Perfect PCC is a straight line in a 2D plot of corresponding X,Y value pairs.

The *Spearman* correlation coefficient does the same for the rank of the observations instead of their values. Perfect SCC is any monotonic line between X and Y values (straight, curved, or zigzag).

PCC and SCC can disagree to considerable extent, depending on the context of the expression differences. The change in a feature's rank depends not so much on the magnitude of the expression change itself, but instead on how many other features have similar expression levels and how close their values are.

## TPM (or RPM)

```{r correlations1, fig.height=8, fig.width=12}
corels1p <- my_pairwise_internal_corels(tpm, colnames(tpm), method="pearson", 
                                       minMean=0, minSingle=0)   # pre-filtered when making the DESeq object
corels1s <- my_pairwise_internal_corels(tpm, colnames(tpm), method="spearman", 
                                       minMean=0, minSingle=0)

print( (corels1p[['frnc']] + theme(legend.position="none")) | 
         (corels1s[['frnc']] + theme(axis.text.y=element_blank())) )
# The axes and fill range are deterministic and fixed, so I can drop the redundant details.
```

```{r correlations2, fig.height=12, fig.width=9}
print( (corels1p[['drc']]) / (corels1s[['drc']] + theme(axis.text.x=element_blank())) )
```

## Variance regularized counts

```{r correlations3, fig.height=6, fig.width=9}
corels2p <- my_pairwise_internal_corels(vstmat, colnames(tpm), method="pearson", 
                                       minMean=0, minSingle=0)
corels2s <- my_pairwise_internal_corels(vstmat, colnames(tpm), method="spearman", 
                                       minMean=0, minSingle=0)

print( (corels2p[['frnc']] + theme(legend.position="none")) | 
         (corels2s[['frnc']] + theme(axis.text.y=element_blank())) )
# The axes and fill range are deterministic and fixed, so I can drop the redundant details.
```

```{r correlations4, fig.height=9, fig.width=9}
print( (corels2p[['drc']]) / (corels2s[['drc']] + theme(axis.text.x=element_blank())) )
```



# DE

The first subsection below contains static plots of *all the genes*.
The plots are generated at sufficient resolution but may be scaled to fit the page width. Simply right-click and open image in new tab to get a more legible view.

The second subsection contains interactive versions of these plots, filtered to show only the genes that meet the thresholds. There you can hover over points to see their ID, zoom in, etc.

The highlighted red points are the up to `r params$ntop` top hits out of all the points that meet the thresholds. This number limit is arbitrary and serves mainly to allow the convenience of labelling potentially interesting hits while also preventing over-crowding the plots. "Top-ness" of hits is ranked roughly based on their "distance" from the origin of the axes in the volcano plots,

If a contrast does not have any hits that meet the thresholds defined at the beginning of this report, a warning message will indicate that there are no hits, and there will be no highlighted points. Instead, the `r params$ntop` "top-est" non-hit points will be listed in the table and shown in the interactive plots for exploration.

```{r DE}
resall <- NULL

# Build model
if (!is.null(params$reducedFormula)){
  deobj <- DESeq(deobj, test='LRT', reduced = as.formula(params$reducedFormula))  # LR test
} else {
  deobj <- DESeq(deobj) # Wald test
}
coeffs <- resultsNames(deobj)[resultsNames(deobj) != "Intercept"]
```

```{r functionDE}
# DE
do_de_plots <- function(contrast, dds = deobj, rpms = tpm, ntop = params$ntop, addPrefix = params$longlabel,
                        pcutoff = params$pcutoff, lfcthreshold = params$lfcthreshold, filterBM=params$filterBaseMean, 
                        prefix=params$prefix, PMtype=colsuffix, rlog=params$rlog){
  # contrast <- coeffs[1]
  highlight <- c("non-significant", "significant, FC low", "significant", paste("significant, top", params$ntop))
  hlcol <- c("grey50", "black", "blue", "red")
  names(hlcol) <- highlight

  # Get DE for given contrast
  lfc <- results(dds, name=contrast, independentFiltering = filterBM, alpha=pcutoff)
  shrink <- lfcShrink(dds, coef=contrast, type='apeglm')
  lfc <- cbind(data.table(name=rownames(lfc)), as.data.table(lfc))
  shrink <- cbind(data.table(name=rownames(shrink)), as.data.table(shrink))
  
  # Precompute useful conversions
  lfc[, mlog10p := -log10(padj)]
  shrink[, mlog10p := -log10(padj)] 
  shrink[, absl2fc := abs(log2FoldChange)]
  
  # Combine shrunken and non-shrunken LFC tables for output, minus identical columns
  outtab <- merge(lfc, shrink[, ! names(shrink) %in% c('baseMean', 'pvalue'), with=FALSE], by="name", all=TRUE, suffixes=c('', '.shrink'))
  
  
  ## Home-brewed selection of top hits to highlight, by euclidian distance from origin.
  # It mostly works sensibly enough, but the selection should not be taken as gospel.
  
  # Thresholds.
  outtab[, meetthresh := !is.na(padj) & absl2fc >= lfcthreshold & padj < pcutoff]
  
  # Down-weight mlog10p for a more balanced selection not dominated by p value.
  ppen <- max(outtab$mlog10p, na.rm=TRUE) / max(outtab$absl2fc, na.rm=TRUE)  # "penalty" factor determined by axes ranges
  outtab[, dist := sqrt((mlog10p / ppen) ^ 2 + log2FoldChange.shrink ^ 2)]
  setorder(outtab, -dist, -absl2fc, -mlog10p, na.last = TRUE)
  
  # Selection helpers
  outtab[, istop := FALSE]
  outtab[(meetthresh), row := 1:.N]
  outtab[meetthresh & row <= ntop, istop := TRUE]  # The top N hits, but they must first actually be hits.
  outtab[, dist := NULL] [, absl2fc := NULL] [, row := NULL]  # they did their job
  outtab[, category := highlight[1]]
  outtab[!is.na(padj.shrink) & padj.shrink < params$pcutoff & !meetthresh, category := highlight[2]]
  outtab[meetthresh & !istop, category := highlight[3]]
  outtab[(istop), category := highlight[4]]
  outtab[, category := factor(category, ordered=TRUE, levels=highlight)]
  
  # Filter out the uninteresting points, to make it lightweight and ggplotly-friendly
  subfc <- outtab[(meetthresh), ]
  # Handle freak cases.
  if (nrow(subfc) <= ntop) {
    subfc <- outtab[abs(log2FoldChange) >= 0.5 & padj < 0.1, ] 
    # Relax thresholds, so there's more context to display in the interactive volcano.
  }
  if (nrow(subfc) < ntop) {
    subfc <- outtab[mlog10p > 0.1, ]
    # Scrape the bottom of the barrel.
  }
  if (nrow(subfc) < ntop) {
    subfc <- head(outtab, n=ntop)
    # Remove thresholds, If subfc is empty, the code breaks. 
    # It's too much hassle to code alternatives for all the places subfc is used.
  }
  
  ## Volcanos
  
  # Static image.
  pv1 <- ggplot(outtab, 
                aes(x=log2FoldChange, y=mlog10p, colour=istop, label=name)) + 
            geom_vline(xintercept = lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_vline(xintercept = -lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_hline(yintercept = -log10(pcutoff), linetype="dashed",  colour="steelblue1") + 
            geom_point(alpha=0.5) +
            geom_text_repel(data=outtab[(istop), ], size=rel(2.5),  colour="red",
                            segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=1, force_pull=1) +
            scale_colour_manual(values=c("black", "red")) +
            labs(x='log2( FC )', y='-log10( Padj )', title=contrast) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  pv2 <- ggplot(outtab, 
                aes(x=log2FoldChange.shrink, y=mlog10p.shrink, colour=istop, label=name)) + 
            geom_vline(xintercept = lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_vline(xintercept = -lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_hline(yintercept = -log10(pcutoff), linetype="dashed",  colour="steelblue1") + 
            geom_point(alpha=0.5) +
            geom_text_repel(data=outtab[(istop), ], size=rel(2.5), colour="red",
                            segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=1, force_pull=1) +
            scale_colour_manual(values=c("black", "red")) +
            labs(x='log2( shrunken FC )', y='-log10( Padj )', title=contrast) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  # Lighter image for interactive plotly. Only points that pass thresholds.
  pvly <- ggplot(subfc, 
                aes(x=log2FoldChange, y=mlog10p, label=name, colour=istop)) + 
            geom_vline(xintercept = lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_vline(xintercept = -lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_hline(yintercept = -log10(pcutoff), linetype="dotted",  colour="steelblue1") + 
            geom_point(alpha=0.5) +
            scale_colour_manual(values=c("black", "red")) +
            labs(x='log2( shrunken FC )', y='-log10( Padj )', title=contrast) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  ## MA
  
  # Static image.
  pma1 <- ggplot(NULL, 
                aes(x=baseMean, y=log2FoldChange, label=name)) + 
            geom_hline(yintercept = 0,  colour="black") + 
            geom_point(data=outtab[padj >= pcutoff, ], colour='grey50', alpha=0.4, size=rel(0.8)) +
            geom_point(data=outtab[padj < pcutoff, ], colour='black', alpha=0.7) +
            geom_point(data=outtab[name %in% subfc[(istop), name], ], colour='red') +
            geom_hline(yintercept = lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_hline(yintercept = -lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_text_repel(data=outtab[(istop), ], colour="red", size=rel(2.5), segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=1, force_pull=1) +
            scale_x_log10() +
            annotation_logticks(base=10, sides='b') +
            labs(y='log2( FC )', y='baseMean', title=contrast) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  pma2 <- ggplot(NULL, 
                aes(x=baseMean, y=log2FoldChange.shrink, label=name, shape= istop)) + 
            geom_hline(yintercept = 0,  colour="black") + 
            geom_point(data=outtab[padj >= pcutoff, ], colour='grey50', alpha=0.4, size=rel(0.8)) +
            geom_point(data=outtab[padj < pcutoff, ], colour='black', alpha=0.7) +
            geom_point(data=outtab[(istop), ], colour='red') +
            geom_hline(yintercept = lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_hline(yintercept = -lfcthreshold, linetype="dashed",  colour="steelblue1") + 
            geom_text_repel(data=outtab[name %in% subfc[(istop), name],], colour="red", size=rel(2.5), segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=1, force_pull=1) +
            scale_x_log10() +
            annotation_logticks(base=10, sides='b') +
            labs(y='log2( shrunken FC )', y='baseMean', title=contrast) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  # Lighter image for interactive plotly. Only points that pass thresholds.
  pmaly <- ggplot(subfc, 
                aes(x=log10(baseMean), y=log2FoldChange, label=name, colour=istop)) + 
            geom_hline(yintercept = 0,  colour="grey50") + 
            geom_point(alpha=0.5) +
            geom_hline(yintercept = lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_hline(yintercept = -lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            scale_colour_manual(values=c("black", "red")) +
            labs(y='log2( FC )', y='log10( Mean )', title=contrast) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  ## Expression heatmap of ntop genes that meet thresholds
  
  # Get the counts for the relevant samples only
  mM <- attr(dds, "modelMatrix")
  refs <- rownames(mM[apply(mM, 1, sum) == 1, , drop=FALSE])
  treats <- rownames(mM)[mM[, contrast] == 1]
  selcnt <- rpms[head(subfc$name, n=ntop), ]
  if (rlog) {
    selvst <- assay(rlog(deobj, blind = TRUE))[head(subfc$name, n=ntop), ]
  } else {
    selvst <- assay(vst(deobj, blind=FALSE))[head(subfc$name, n=ntop), ]
  }
  
  if (is.null(dim(selcnt))) {
    # if there is only one hit
    selvst <- as.data.frame( c(as.list(selvst[c(refs, treats)]), list(name=subfc$name)) )
    selvst$type <- ifelse(rlog, "rlog_count", "VST_count")
    selcnt <- as.data.frame( c(as.list(selcnt[c(refs, treats)]), list(name=subfc$name)) )
    selcnt$type <- PMtype
    # selcnt <- rbind(selcnt, selvst)
    selcnt <- melt(selcnt, id.vars="name", variable.name="sample", value.name=PMtype)
    selvst <- melt(selvst, id.vars="name", variable.name="sample", value.name=ifelse(rlog, "rlog_count", "VST_count"))
    # rn <- subfc$name
  } else {
    selcnt <- selcnt[, c(refs, treats)]
    selvst <- selvst[, c(refs, treats)]
    
    # Cluster row and columns
    cfit <- hclust(dist(scale(t(selvst), center=TRUE))) # cluster columns
    rfit <- hclust(dist(scale(selvst, center=FALSE)))    # cluster rows
    selcnt <- selcnt[rfit$order, cfit$order]
    selvst <- selvst[rfit$order, cfit$order]
    cn <- colnames(selvst)
    rn <- rownames(selvst)
    
    # Tidy
    selcnt <- as.data.table(cbind(data.table(name=rownames(selcnt)), as.data.frame(selcnt)))
    selcnt[, name := factor(name, ordered=TRUE, levels=rn)]
    selcnt[, type := PMtype]
    selvst <- as.data.table(cbind(data.table(name=rownames(selvst)), as.data.frame(selvst)))
    selvst[, name := factor(name, ordered=TRUE, levels=rn)]
    selvst[, type := ifelse(rlog, "rlog_count", "VST_count")]
    # selcnt <- rbind(selcnt, selvst)
    selcnt <- melt(selcnt, id.vars=c("name", "type"), variable.name="sample", value.name=PMtype)
    selcnt[, sample := factor(sample, ordered=TRUE, levels=cn)]
    selvst <- melt(selvst, id.vars=c("name", "type"), variable.name="sample", value.name=ifelse(rlog, "rlog_count", "VST_count"))
    selvst[, sample := factor(sample, ordered=TRUE, levels=cn)]
  }
  
  ph1 <- ggplot(selcnt, aes(x=sample, y=name, fill=log10(selcnt[["TPM"]]))) +
            geom_tile() +
            # facet_grid(. ~ type) +
            scale_fill_gradient(high="yellow2", low="darkgreen", na.value = "black", name="log10(TPM)") +
            labs(title=contrast) +
            theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5),
                  panel.grid = element_blank())
  
  ph2 <- ggplot(selvst, aes_string(x="sample", y="name", fill=ifelse(rlog, "rlog_count", "VST_count"))) +
            geom_tile() +
            # facet_grid(. ~ type) +
            scale_fill_gradient(high="yellow2", low="darkgreen", na.value = "black") +
            labs(title=contrast) +
            theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5),
                  panel.grid = element_blank())
  
  ## Expression scatters
  
  # Add expression
  
  cnt <- merge( data.table(name = rownames(counts(dds)),
                           # counts(dds)[outtab$name, c(refs, treats), drop=FALSE],
                           refMean = rowMeans(counts(dds)[outtab$name, refs, drop=FALSE]),
                           treatMean = rowMeans(counts(dds)[outtab$name, treats, drop=FALSE]),
                           meanCount = rowMeans(counts(dds)[outtab$name, c(refs, treats), drop=FALSE]),
                           refStDev = sqrt(rowVars(counts(dds)[outtab$name, refs, drop=FALSE])),
                           treatStDev = sqrt(rowVars(counts(dds)[outtab$name, treats, drop=FALSE])) ),
                data.table(name=rownames(rpms), 
                           # rpms[, c(refs, treats), drop=FALSE],
                           refMeanTPM = rowMeans(rpms[, refs]),
                           treatMeanTPM = rowMeans(rpms[, treats]),
                           meanScaledCount = rowMeans(rpms[, c(refs, treats )]) ),
                all=TRUE, by="name" )
  
  outtab <-merge(outtab,
                 cnt,
                 all=TRUE, by="name")
  
 
  # Increment the 0s so they survive the log-transformation, but in a way they don't mix with non-zero data.
  # If data has been pre-filtered with minMean, there should be no remaining zeros.
  zeros <- min(outtab[refMeanTPM > 0, refMeanTPM], outtab[treatMeanTPM > 0, treatMeanTPM]) / 10
  
  pe1 <- ggplot(NULL, aes(x=refMeanTPM + zeros, y=treatMeanTPM + zeros, label=name, colour=category)) +
      geom_abline(intercept = 0, slope = 1, colour='black') +
      geom_point(data=outtab[category == highlight[1], ], alpha=0.4, size=rel(0.8)) +
      geom_point(data=outtab[category == highlight[2], ], alpha=0.7, size=rel(0.8)) +
      geom_point(data=outtab[category == highlight[3], ], alpha=0.7) +
      geom_point(data=outtab[category == highlight[4], ]) +
      geom_label_repel(data=outtab[category == highlight[4], ], size=rel(2.5), colour="red",
                       segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=10, force_pull=5) +
      scale_x_log10() + 
      scale_y_log10() +
      scale_colour_manual(values=hlcol) +
      annotation_logticks(base=10, sides='lrtb') +
      labs(title=contrast, x=paste('reference Mean', PMtype), y=paste('treatment Mean', PMtype)) +
      theme(panel.grid.minor = element_blank())
  
  pe1ly <- ggplot(NULL, aes(x=refMeanTPM + zeros, y=treatMeanTPM, label=name, colour=category)) +
      geom_abline(intercept = 0, slope = 1, colour='black') +
      geom_point(data=outtab[category == highlight[3], ], alpha=0.7) +
      geom_point(data=outtab[category == highlight[4], ]) +
      scale_x_log10() + 
      scale_y_log10() +
      scale_colour_manual(values=hlcol) +
      labs(title=contrast, x=paste('reference Mean', PMtype), y=paste('treatment Mean', PMtype)) +
      theme(legend.position = "none", panel.grid.minor = element_blank()) 
  
  pe2 <- ggplot(NULL, aes(x=refMeanTPM + zeros, y=refStDev, label=name, colour=category)) +
      geom_point(data=outtab[category == highlight[1], ], alpha=0.4, size=0.8) +
      geom_point(data=outtab[category == highlight[2], ], alpha=0.7, size=0.8) +
      geom_point(data=outtab[category == highlight[3], ], alpha=0.7) +
      geom_point(data=outtab[category == highlight[4], ]) +
      geom_label_repel(data=outtab[category == highlight[4], ], size=rel(2.5), colour="red",
                       segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=10, force_pull=5) +
      scale_x_log10() + 
      scale_y_log10() +
      scale_colour_manual(values=hlcol) +
      annotation_logticks(base=10, sides='lrtb') +
      labs(title=contrast, x=paste('reference Mean', PMtype), y='reference St.Dev.') +
      theme(panel.grid.minor = element_blank()) 
  
  pe3 <- ggplot(NULL, aes(x=treatMeanTPM, y=treatStDev, label=name, colour=category)) +
      geom_point(data=outtab[category == highlight[1], ], alpha=0.4, size=0.8) +
      geom_point(data=outtab[category == highlight[2], ], alpha=0.7, size=0.8) +
      geom_point(data=outtab[category == highlight[3], ], alpha=0.7) +
      geom_point(data=outtab[category == highlight[4], ]) +
      geom_label_repel(data=outtab[category == highlight[4], ], size=rel(2.5), colour="red",
                       segment.size = 0.3, min.segment.length=0, max.overlaps=1e4, force=10, force_pull=5) +
      scale_x_log10() + 
      scale_y_log10() +
      scale_colour_manual(values=hlcol) +
      annotation_logticks(base=10, sides='lrtb') +
      labs(title=contrast, x=paste('treatment Mean', PMtype), y='treatment St.Dev.') +
      theme(panel.grid.minor = element_blank()) 
  
  ## Table pt2
  
  hashits <- any(outtab[, meetthresh], na.rm=TRUE)
  
  setnames(outtab, sub('TPM|RPM', paste0('.', PMtype), names(outtab)))
  
  virgin <- NULL
  if (addPrefix) {
    # Pristine copy, without prefixes. Drop columns I don't need
    keep <- names(outtab)[!grepl("stat|mlog10p.shrink|padj.shrink|lfcSE|pvalue|meetthresh|istop|category|StDev", names(outtab))]
    virgin <- copy(outtab[, keep, with=FALSE])
    
    # Prepare column names for merging the files later
    prefix <- paste(prefix,
                     # paste(sub('[^A-Za-z0-9_\\-.+~]', '-', design(dds), perl=TRUE), collapse=''),
                     contrast, sep='.')
    # # Add prefix
    # setnames(outtab,
    #          c(names(outtab)[1],              # keep uniform name across tables for the joining key
    #            paste(prefix,
    #                  names(outtab)[2:length(outtab)], sep='.') ) )
    
    # Add as suffix instead. Makes life easier in spotfire
    setnames(outtab, c(names(outtab)[1],      # keep uniform name across tables for use as joining key
                       paste(names(outtab)[2:length(outtab)],  prefix, sep='.')) )
  
  }
  
  return(list(contrast=contrast, 
              pv1=pv1, pv2=pv2, pvly=ggplotly(pvly, dynamicTicks = TRUE),
              pma1=pma1, pma2=pma2, pmaly=ggplotly(pmaly, dynamicTicks = TRUE),
              pe1=pe1, pe2=pe2, pe3=pe3, pe1ly=ggplotly(pe1ly, dynamicTicks = TRUE),
              ph1=ph1, ph2=ph2, 
              tophits=rn, hashits=hashits,
              outtab=outtab, virgin=virgin))
}
```


```{r DEcontinue}
# Contrast against the assigned reference
resall <- lapply(coeffs, function(contrast) {
  # contrast <-  coeffs[1]
  message(contrast)
  do_de_plots(contrast) 
})
names(resall) <- vapply(resall, function(x) { x$contrast }, character(1))


if (length(cD) == 1 && params$roundrobin && length(coeffs) > 1) {
  # Determine which was the reference and rotate each other level as reference.
  ## I don't remember why this works, P
  ## Also possibly designed for 3 conditions. Not sure how/if it works correctly for more than 3.
  isref <- vapply(levels(cD[[1]]), function(x) {
                    all(grepl(x, coeffs[1]), grepl(x, coeffs[2]))
           }, logical(1) )
  ref <- levels(cD[[1]])[isref]
  remaining <- levels(cD[[1]])[!isref]
  for (lev in levels(cD[[1]])[!isref]) {
    # lev <- levels(cD[[1]])[!isref][1]
    deobj2 <- deobj
    deobj2[[names(cD)[1]]] <- relevel(deobj2[[names(cD)[1]]], ref= lev)
    if (!is.null(params$reducedFormula)){
      deobj2 <- DESeq(deobj2, test='LRT', reduced = as.formula(params$reducedFormula))  # LR test
    } else {
      deobj2 <- DESeq(deobj2) # Wald test
    }
    coeffs <- resultsNames(deobj2)[resultsNames(deobj2) != "Intercept"]
    resall2 <- lapply(coeffs, function(contrast) { message(contrast); do_de_plots(contrast, dds = deobj2) })
    names(resall2) <- vapply(resall2, function(x) { x$contrast }, character(1))
    resall <- c(resall, resall2)
  }
  
  # The rotation is brute-force-y and creates duplicate results A vs B and B vs A. Get rid of redundant contrasts.
  
  allcoeffs <- vapply(resall, function(x) { x$contrast }, character(1))
  # The reference condition should always be on the right-hand side of the VS. 
  # Careful, the reference might also be a substring of another condition, so the pattern has to be quite explicit,
  keep <- allcoeffs[!grepl(paste0("_", ref, "_vs"), allcoeffs, perl=TRUE)]
  # For the rest, either of each duplicate is assumed to be equally intuitive. 
  # Let R create a vector of pairwise combinations.
  uniqcoeffs <- vapply(as.data.frame(combn(levels(cD[[1]]), 2), stringsAsFactors=FALSE),
                          function(x) { paste(names(cD)[1], x[2], "vs", x[1], sep="_") },
                          character(1) )
  uniqcoeffs <- uniqcoeffs[!grepl(paste0("_", ref, "_vs|vs_", ref, "$"), uniqcoeffs)] # already filtered the coefficients involving reference.
  keep <- keep[! keep %in% uniqcoeffs]
  resall <- resall[keep]
}
```

## Results by comparison

IMPORTANT: In the name of each comparison, the condition used as **"reference" is always shown to the right** of the `vs` in the name, whereas the condition used as **"treatment" is always shown on the left** of the `vs`.

```{r expov, warning=FALSE, fig.height=9, fig.width=10}
for (res in resall) {
  # res <- resall[[1]]
  
  # Are there any hits?
  # message(paste(res$contrast, res$hashits))
  if (!res$hashits) {
    message(paste("No hits meeting criteria in ", res$contrast,"! Listing outermost points instead."))
  }

  # Hit list
  ##########
  
  cat("\nComparison: ")
  cat(res[["contrast"]])
  cat("\n\nTop hits (or, if no hits exist, nearest to being hits):\n")
  cat(as.character(res[["tophits"]]))
  cat("\n")
  
  
  # Plots
  ################
  
  print(res[["pe1"]])
  print(res[["pv1"]])
  print(res[["pma1"]])
  print(res[["ph2"]])
}
```


## Interactive filtered Volcanos and Expressions

All genes that do not meet both the fold-change threshold and the significance cutoff are removed completely from these plots to reduce visual clutter and to keep the report file lighteight.

```{r mas, fig.height=6, fig.width=7, warning=FALSE}
# These plots are not faceted, so need less width.

ly <- lapply(resall, function(res) {
  # res <- resall[[1]]
  list(res[["pvly"]], res[["pe1ly"]])
})

htmltools::tagList(ly)
```

## Expression heatmap

Heatmap of all the top hits from all the comparisons in this report.

```{r dexp, fig.height=15, fig.width=7}
# Collect all the top50s
allhits <- Reduce(union, lapply(resall, function(res) {
  return(res[["tophits"]])
}))

# Counts
mat1 <- vstmat[allhits, ]
mat2 <- tpm[allhits, ]

# Custer row and columns
cfit <- hclust(dist(scale(t(mat1), center=TRUE))) # cluster columns
rfit <- hclust(dist(scale(mat1, center=FALSE)))    # cluster rows
cn <- colnames(mat1)[cfit$order]
rn <- rownames(mat1)[rfit$order]

allhitdf <- as.data.table(mat2)
allhitdf[, Feature := rownames(mat2)]
allhitdf <- melt(allhitdf, value.name = "RPM", variable.name = "Sample", id.vars = "Feature")
allhitdf[, Feature := ordered(Feature, levels=rn)]
allhitdf[, Sample := ordered(Sample, levels=cn)]

pallexp <- ggplot(allhitdf, aes(y=Feature, x=Sample, fill=log10(RPM))) +
  geom_tile() +
  scale_fill_gradient(high="skyblue", low="darkblue", na.value='black') +
  labs(y='', x='') +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5, size=rel(1)),
        axis.text.y = element_text(size=rel(0.6)),
        panel.grid = element_blank())

allhitdf <- as.data.table(mat1)
allhitdf[, Feature := rownames(mat1)]
allhitdf <- melt(allhitdf, value.name = ifelse(params$rlog, "rlog_count", "VST_count"), 
                 variable.name = "Sample", id.vars = "Feature")
allhitdf[, Feature := ordered(Feature, levels=rn)]
allhitdf[, Sample := ordered(Sample, levels=cn)]

pallvst <- ggplot(allhitdf, 
                  aes_string(y="Feature", x="Sample", fill=ifelse(params$rlog, "rlog_count", "VST_count"))) +
  geom_tile() +
  scale_fill_gradient(high="skyblue", low="darkblue", na.value = "black") +
  labs(y='', x='') +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5, size=rel(1)),
        axis.text.y = element_text(size=rel(0.6)),
        panel.grid = element_blank())

print(pallvst)
print(pallexp)
```


# Files out

## Tables

```{r csv}
for (res in resall) {
  # Drop columns I don't need
  keep <- names(res$outtab)[!grepl("stat|mlog10p.shrink|padj.shrink|lfcSE|pvalue|meetthresh|istop|category|StDev", names(res$outtab))]
  fwrite(res$outtab[, keep, with=FALSE],
         file = file.path(params$baseDir,
                          params$resultsDir,
                          paste(params$prefix, res$contrast, 'deseq2.tsv', sep='.')),
         sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
  if (params$longlabel)
    fwrite(res$virgin,
         file = file.path(params$baseDir,
                          params$resultsDir,
                          paste(params$prefix, res$contrast, 'deseq2.nolab.tsv', sep='.')),
         sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
}
```

## Plots to PDF

```{r pdf}
pdf(file.path(params$baseDir, 
              params$resultsDir, 
              paste(params$prefix, 'deseq2.pdf', sep='.')),
    title=paste(params$prefix, paste(sub('[^A-Za-z0-9_\\-.+~]', '-', design(deobj), perl=TRUE), collapse=''), 'deseq2', sep='.'),
    width=15, height=15)



# Correlation plots
print(corels1p[['frnc']] + labs(substitle=colsuffix))
print(corels1s[['drc']] + labs(substitle=colsuffix))
print(corels2p[['frnc']] + labs(substitle='VST counts'))
print(corels2s[['drc']] + labs(substitle='VST counts'))

# DE plots
for (res in resall){
  # Static plots
  print(res[["pv1"]])
  print(res[["pv2"]])
  print(res[["pma1"]])
  print(res[["pma2"]])
  print(res[["pe1"]])
  print(res[["pe2"]])
  print(res[["pe3"]])
  print(res[["ph1"]])
  print(res[["ph2"]])
}
# print(pallexp)
# print(pallvst)

dev.off()
```



# Session info

```{r}
sessionInfo()
```
