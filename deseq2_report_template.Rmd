---
title: "DE Report"
author: "Kimon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
    collapsed: false
params:
  derds: "null.RDS"     # MUST be specified, DESeq2 Dataset object file (before model creation)
  rmrds: "null.RDS"     # MUST be specified, RPM matrix object
  prefix: ""
  resultsDir: "."
  baseDir: "."
  pcutoff: 0.05
  lfcthreshold: 1
  ntop: 50              # maximum number of hits to list
  ppen: 5               # Weight factor for -log10p vs l2fc, when selecting hits by distance from the origin of the axes of the DE volcanoes.
  minL: 0.75            # Minimum component loading, for selection of features to report in PCA
  minCount: 10          # Minimum sum of counts across samples per gene (already applied, just here for parameter documentation in the report)
  filterBaseMean: True  # DESeq2 independent filtering
  reducedFormula: 'NULL'
  roundrobin: True      # do all-vs-all comparisons (for single-factor comparisons only). Otherwise only vs assigned reference condition.
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE)
```


# Setup

```{r libraries}
library(DESeq2)
library(data.table)
library(ggplot2)
library(plotly)
library(htmltools)
# library(topGO)
# library(org.Mm.eg.db)
library(patchwork)
# library(ggExtra)
library(ggrepel)

# ggplot2 base theme
theme_set(theme_bw())

data.table::setDTthreads(1L)

options(scipen=2)

# params <- list(derds = ddsrds, rmrds = rpmrds, ntop = opt$ntop, pcutoff = opt$pcutoff, lfcthreshold = opt$lfcthreshold, baseDir = opt$baseDir, resultsDir = opt$resultsDir, prefix = autoname, ppen = 5, minL=0.75, minCount=opt$minCount, filterBaseMean=opt$bmF, reducedFormula = opt$reducedFormula, roundrobin = opt$all)


if (!is.null(params$reducedFormula)){
  if (params$reducedFormula == 'NULL') {
    params$reducedFormula <- NULL
  }
}
```

```{r preprocess}
deobj <- readRDS(params$derds)
rpm <- readRDS(params$rmrds)
# ctsmat <- counts(deobj)
message(params$derds)
vstmat <- assay(vst(deobj, blind=FALSE))     # Variance stabisized counts
cD <- colData(deobj)[, 1:length(colData(deobj)), drop=FALSE]  # before model building, there in no size factor as last column

cat(paste("min allowed sum of raw counts across relevant samples:", params$minCount))
cat(paste("Significance level:", params$pcutoff))
cat(paste("independent filtering:", params$filterBaseMean))
cat(paste("log2FC threshold:", params$lfcthreshold, ", (i.e.", 2 ^ params$lfcthreshold, "-fold change)"))
cat(paste("max # of top hits to highlight:", params$ntop))
cat(paste("Expand contrasts to include pairs without the assigned reference:", params$roundrobin))
```

```{r functionDE}
# DE
do_de_plots <- function(contrast, dds = deobj, rpms = rpm, ntop = params$ntop, ppen = params$ppen, 
                        pcutoff = params$pcutoff, lfcthreshold = params$lfcthreshold, filterBM=params$filterBaseMean){
  # contrast <- coeffs[1]
  
  # Get DE for given contrast
  lfc <- results(dds, name=contrast, independentFiltering = filterBM, alpha=pcutoff)
  shrink <- lfcShrink(dds, coef=contrast, type='apeglm')
  
  lfc <- cbind(data.table(name=rownames(lfc)), as.data.table(lfc))
  lfc[, mlog10p := -log10(padj)] [, type := "raw_L2FC"]
  shrink <- cbind(data.table(name=rownames(shrink)), as.data.table(shrink))
  shrink[, mlog10p := -log10(padj)] [, type := "shrunken_L2FC"] [, absl2fc := abs(log2FoldChange)]
  
  shrink[, meetthresh := absl2fc >= lfcthreshold & padj < pcutoff]
  shrink[complete.cases(shrink), dist := sqrt((mlog10p/ppen)^2 + log2FoldChange^2)]  # logp is usually much bigger than logfc, so down-weight it a little
  setorder(shrink, -dist, -mlog10p, -absl2fc, na.last = TRUE)
  shrink[, istop := FALSE]
  shrink[1:ntop, istop := meetthresh]  # The top N hits, must first be hits.
  
  # if (!any(shrink$meetthresh)) {
  #   warning(paste("WARNING -", contrast, "- No points meet the L2FC and Padj criteria!"))
  # }
  
  # Filter out the uninteresting points, to make it lightweight and ggplotly-friendly
  subfc <- shrink[(meetthresh), ]
  # Handle freak cases.
  if (nrow(subfc) <= ntop) {
    subfc <- shrink[abs(log2FoldChange) >= 0.5 & padj < 0.1, ] 
    # Relax thresholds, so there's more context to display in the interactive volcano.
  }
  if (nrow(subfc) < ntop) {
    subfc <- shrink[mlog10p > 0.1, ]
    # Scrape the bottom of the barel.
  }
  if (nrow(subfc) < ntop) {
    subfc <- head(shrink, n=ntop)
    # Remove thresholds, If subfc is empty, the code breaks. 
    # It's too much hassle to code alternatives for all the places subfc is used.
  }
  
  
  outtab <- rbind(lfc, shrink, fill=TRUE)
  
  # Volcanos
  
  # Static image.
  pv1 <- ggplot(outtab, 
                aes(x=log2FoldChange, y=mlog10p, 
                    shape= name %in% subfc[(istop), name], 
                    colour=name %in% subfc[(istop), name])) + 
            facet_grid( . ~ type) +
            geom_point(size=rel(0.8), alpha=0.5) +
            geom_vline(xintercept = lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_vline(xintercept = -lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_hline(yintercept = -log10(pcutoff), linetype="dotted",  colour="steelblue1") + 
            scale_colour_manual(values=c("black", "red")) +
            scale_shape_manual(values=c(16, 17)) +
            labs(x='log2( FC )', y='-log10( Padj )', title=contrast) +
            theme(legend.position = "none", panel.grid = element_blank())
  # pv1a <- ggplot(outtab, 
  #               aes(x=log2FoldChange, y=mlog10p, 
  #                   shape= name %in% subfc[(istop), name], 
  #                   colour=name %in% subfc[(istop), name])) + 
  #           facet_grid( type ~ . ) +
  #           geom_point(size=0.8, alpha=0.5) +
  #           geom_vline(xintercept = lfcthreshold, linetype="dotted",  colour="steelblue1") + 
  #           geom_vline(xintercept = -lfcthreshold, linetype="dotted",  colour="steelblue1") + 
  #           geom_hline(yintercept = -log10(pcutoff), linetype="dotted",  colour="steelblue1") + 
  #           scale_colour_manual(values=c("black", "red")) +
  #           scale_shape_manual(values=c(16, 17)) +
  #           labs(x='log2( FC )', y='-log10( Padj )', title=contrast) +
  #           theme(legend.position = "none", panel.grid = element_blank())
  
  # Lighter image for interactive plotly. Only points that pass thresholds.
  pv2 <- ggplot(subfc, 
                aes(x=log2FoldChange, y=mlog10p, label=name,
                    shape= name %in% subfc[(istop), name],
                    colour=name %in% subfc[(istop), name])) + 
            geom_vline(xintercept = lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_vline(xintercept = -lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_hline(yintercept = -log10(pcutoff), linetype="dotted",  colour="steelblue1") + 
            geom_point(alpha=0.5) +
            scale_colour_manual(values=c("black", "red")) +
            scale_shape_manual(values=c(16, 17)) +
            labs(x='log2( FC )', y='-log10( Padj )', title=contrast) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  # MA
  
  # Static image.
  pma1 <- ggplot(outtab, 
                aes(x=baseMean, y=log2FoldChange, alpha=padj < pcutoff, 
                    shape= name %in% subfc[(istop), name],
                    colour=name %in% subfc[(istop), name])) + 
            facet_grid( . ~ type) +
            geom_hline(yintercept = 0,  colour="grey50") + 
            geom_point(size=rel(0.8)) +
            geom_hline(yintercept = lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_hline(yintercept = -lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            scale_x_log10() +
            annotation_logticks(base=10, sides='b') +
            scale_colour_manual(values=c("black", "red")) +
            # scale_alpha_continuous(na.value=0.05) +
            scale_alpha_manual(values=c(0.25, 0.8), na.value=0.05) +
            labs(y='log2( FC )', y='baseMean', title=contrast) +
            theme(legend.position = "none", panel.grid = element_blank())
  # pma1a <- ggplot(outtab, 
  #               aes(x=baseMean, y=log2FoldChange, alpha=padj < pcutoff, 
  #                   shape= name %in% subfc[(istop), name],
  #                   colour=name %in% subfc[(istop), name])) + 
  #           facet_grid( type ~ . ) +
  #           geom_hline(yintercept = 0,  colour="grey50") + 
  #           geom_point(size=0.8) +
  #           geom_hline(yintercept = lfcthreshold, linetype="dotted",  colour="steelblue1") + 
  #           geom_hline(yintercept = -lfcthreshold, linetype="dotted",  colour="steelblue1") + 
  #           scale_x_log10() +
  #           annotation_logticks(base=10, sides='b') +
  #           scale_colour_manual(values=c("black", "red")) +
  #           # scale_alpha_continuous(na.value=0.05) +
  #           scale_alpha_manual(values=c(0.25, 0.8), na.value=0.05) +
  #           labs(y='log2( FC )', y='baseMean', title=contrast) +
  #           theme(legend.position = "none", panel.grid = element_blank())
  
  # Lighter image for interactive plotly. Only points that pass thresholds.
  pma2 <- ggplot(subfc, 
                aes(x=log10(baseMean), y=log2FoldChange, label=name,
                    shape= name %in% subfc[(istop), name],
                    colour=name %in% subfc[(istop), name])) + 
            geom_hline(yintercept = 0,  colour="grey50") + 
            geom_point(alpha=0.5) +
            geom_hline(yintercept = lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            geom_hline(yintercept = -lfcthreshold, linetype="dotted",  colour="steelblue1") + 
            scale_colour_manual(values=c("black", "red")) +
            labs(y='log2( FC )', y='log10( Mean )', title=contrast) +
            theme(legend.position = "none", panel.grid = element_blank())
  
  # Expression heatmap of ntop genes that meet thresholds
  
  # Get the counts for the relevant samples only
  mM <- attr(dds, "modelMatrix")
  refs <- rownames(mM[apply(mM, 1, sum) == 1, , drop=FALSE])
  treats <- rownames(mM)[mM[, contrast] == 1]
  selvst <- assay(vst(dds, blind=FALSE))[head(subfc$name, n=ntop), ]
  selcnt <- rpms[head(subfc$name, n=ntop), ]
  if (is.null(dim(selcnt))) {
    # if there is only one hit
    selvst <- as.data.frame( c(as.list(selvst[c(refs, treats)]), list(name=subfc$name)) )
    selvst$type <- "VST count"
    selcnt <- as.data.frame( c(as.list(selcnt[c(refs, treats)]), list(name=subfc$name)) )
    selcnt$type <- "RPM"
    # selcnt <- rbind(selcnt, selvst)
    selcnt <- melt(selcnt, id.vars="name", variable.name="sample", value.name="RPM")
    selvst <- melt(selvst, id.vars="name", variable.name="sample", value.name="VST_count")
    # rn <- subfc$name
  } else {
    selcnt <- selcnt[, c(refs, treats)]
    selvst <- selvst[, c(refs, treats)]
    
    # Custer row and columns
    cfit <- hclust(dist(scale(t(selvst), center=TRUE))) # cluster columns
    rfit <- hclust(dist(scale(selvst, center=FALSE)))    # cluster rows
    selcnt <- selcnt[rfit$order, cfit$order]
    selvst <- selvst[rfit$order, cfit$order]
    cn <- colnames(selvst)
    rn <- rownames(selvst)
    
    # Scale VST to log(RPM), so they can share the fill gradient.
    # selvst <- selvst * (median(selcnt) / median(selvst))
    
    # Tidy
    selcnt <- as.data.table(cbind(data.table(name=rownames(selcnt)), as.data.frame(selcnt)))
    selcnt[, name := factor(name, ordered=TRUE, levels=rn)]
    selcnt[, type := "RPM"]
    selvst <- as.data.table(cbind(data.table(name=rownames(selvst)), as.data.frame(selvst)))
    selvst[, name := factor(name, ordered=TRUE, levels=rn)]
    selvst[, type := "VST count"]
    # selcnt <- rbind(selcnt, selvst)
    selcnt <- melt(selcnt, id.vars=c("name", "type"), variable.name="sample", value.name="RPM")
    selcnt[, sample := factor(sample, ordered=TRUE, levels=cn)]
    selvst <- melt(selvst, id.vars=c("name", "type"), variable.name="sample", value.name="VST_count")
    selvst[, sample := factor(sample, ordered=TRUE, levels=cn)]
  }

  pe1 <- ggplot(selcnt, aes(x=sample, y=name, fill=log10(RPM))) +
            geom_tile() +
            facet_grid(. ~ type) +
            scale_fill_gradient(high="white", low="darkgreen", na.value = "black") +
            labs(title=contrast) +
            theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5),
                  panel.grid = element_blank())
  
  pe2 <- ggplot(selvst, aes(x=sample, y=name, fill=VST_count)) +
            geom_tile() +
            facet_grid(. ~ type) +
            scale_fill_gradient(high="white", low="darkgreen", na.value = "black") +
            labs(title=contrast) +
            theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5),
                  panel.grid = element_blank())
  
  # Table
  
  # Add shrunken LFC column to normal LFC table. dcast is a glorified rename, but without changing the original (it made more sense when this block located earlier in the function)
  outtab <- merge(dcast(lfc, ... ~ type, value.var = 'log2FoldChange'),
                  dcast(shrink, ... ~ type, value.var = 'log2FoldChange')[, .(name, shrunken_L2FC)], 
                  by='name')
  outtab[, refStDev := sqrt(rowVars(counts(dds)[outtab$name, refs, drop=FALSE])) ]
  outtab[, treatStDev := sqrt(rowVars(counts(dds)[outtab$name, treats, drop=FALSE])) ]
  outtab[, refMean := rowMeans(counts(dds)[outtab$name, refs, drop=FALSE]) ]
  outtab[, treatMean := rowMeans(counts(dds)[outtab$name, treats, drop=FALSE]) ]
  outtab[, refMeanRPM := rowMeans(rpms[outtab$name, refs, drop=FALSE]) ]
  outtab[, treatMeanRPM := rowMeans(rpms[outtab$name, treats, drop=FALSE]) ]
  
  # Prepare column names for merging the files later
  setnames(outtab, 
           c(names(outtab)[1],              # keep uniform name across tables for the joining key
             paste(params$prefix, 
                   paste(sub('[^A-Za-z0-9_\\-.+~]', '-', design(dds), perl=TRUE), collapse=''), 
                   contrast, 
                   names(outtab)[2:length(outtab)], sep='.') ) )       # make the other columns unique
  
  
  return(list(contrast=contrast, 
              pv1=pv1, pv2=ggplotly(pv2, dynamicTicks = TRUE), # pv1a=pv1a,
              pma1=pma1, pma2=ggplotly(pma2, dynamicTicks = TRUE), # pma1a=pma1a,
              pe1=pe1, pe2=pe2, 
              tophits=rn, hashits=any(shrink$meetthresh, na.rm=TRUE),
              outtab=outtab))
  # resall <- list(list(contrast=contrast, pv1=pv1, pv2=ggplotly(pv2, dynamicTicks = TRUE), pma1=pma1, pma2=ggplotly(pma2, dynamicTicks = TRUE), pe1=pe1, pe2=pe2,tophits=rn, hashits=any(shrink$meetthresh), outtab=outtab))
}
```

```{r functionC}
# Correlations
my_pairwise_internal_corels <- function(mat = rpm, samples = row.names(colData(deobj)), method = "pearson", prefix=file.path(params$baseDir, params$resultsDir, params$prefix), txs=3) {
  # Correlations
  cormat <- cor(mat, method=method)
  
  # Cluster
  hcfit <- hclust(dist(scale(cormat, center=TRUE)))
  rn <- rownames(cormat)
  cormat <- cormat[samples, samples]                    # Supplied order
  cormat2 <- cormat                                     # Duplicate on which to delete the diagonal with original order.
  cormat3 <- cormat[rn[hcfit$order], rn[hcfit$order]]   # Duplicate on which to delete the diagonal with clustered order.
  cormat4 <- cormat3
  
  # Delete diagonal half for the numeric labels.
  for (r in 1:nrow(cormat2)) {
    for (c in 1:ncol(cormat2)) {
      if (c <= r) {
        cormat2[r, c] <- NA_real_
      }
    }
  }
  for (r in 1:nrow(cormat4)) {
    for (c in 1:ncol(cormat4)) {
      if (c <= r) {
        cormat4[r, c] <- NA_real_
      }
    }
  }
  
  # Restructure for plotting.
  rn <- rownames(cormat)
  cormat <- as.data.table(cormat)
  cormat[, observation1 := factor(rn, ordered=TRUE, levels=rn)]
  cormat <- melt(cormat, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat[, observation2 := factor(observation2, ordered=TRUE, levels=rn)]
  
  rn2 <- rownames(cormat2)
  cormat2 <- as.data.table(cormat2)
  cormat2[, observation1 := factor(rn2, ordered=TRUE, levels=rn2)]
  cormat2 <- melt(cormat2, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat2[, observation2 := factor(observation2, ordered=TRUE, levels=rn2)]
  cormat2 <- cormat2[!is.na(Correlation)]
  
  rn3 <- rownames(cormat3)
  cormat3 <- as.data.table(cormat3)
  cormat3[, observation1 := factor(rn3, ordered=TRUE, levels=rn3)]
  cormat3 <- melt(cormat3, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat3[, observation2 := factor(observation2, ordered=TRUE, levels=rn3)]
  
  rn4 <- rownames(cormat4)
  cormat4 <- as.data.table(cormat4)
  cormat4[, observation1 := factor(rn3, ordered=TRUE, levels=rn4)]
  cormat4 <- melt(cormat4, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat4[, observation2 := factor(observation2, ordered=TRUE, levels=rn4)]
  cormat4 <- cormat4[!is.na(Correlation)]
  
  # Text colour switch for the dynamic range
  m <- min(cormat4$Correlation, na.rm=TRUE)
  M <- max(cormat4$Correlation, na.rm=TRUE)
  colourswitch <- c( m + 0.49 * (M-m),  m + 0.51 * (M-m) ) 
  
  
  # Square. Custom order. No values. Full range.
  p1 <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Custom order. No values. Dynamic range.
  p1a <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5),
          panel.grid = element_blank() )
  
  # Triangle. Custom order. With values. Full range.
  p2 <- ggplot(cormat2, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.70 & Correlation <= 0.70 ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="forestgreen", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Triangle. Custom order. With values. Dynamic range.
  p2a <- ggplot(cormat2, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Custom order. With values. Full range.
  p12 <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat2, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.70 & Correlation <= 0.70 ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c("black", "white"), na.value="forestgreen", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Custom order. With values. Dyhamic range.
  p12a <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat2, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Clustered order. No values. Dyhamic range.
  p3 <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=1, vjust=0.5),
          panel.grid = element_blank() )
  
 # Triangle. Clustered order. with values. Dyhamic range.
  p4 <- ggplot(cormat4, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Clustered order. With values. Dyhamic range.
  p34 <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat4, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +scale_x_discrete(position = "top") +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  
  fwrite(dcast(cormat2, observation1 ~ observation2, value.var = "Correlation"),
         file=paste0(prefix, '_cor.txt'),
         sep='\t', quote = FALSE, row.names = FALSE, col.names = TRUE)
  
  
  return( list(full=p1, dyna=p2, combo1=p12, act1=p3, act2=p4, combo2=p34, full2=p1a, dyna2=p2a, combo3=p12a) )
}
```


# Correlations
 
Correlations of the samples, based on the raw and the Variance-Stabilisation-Transformed counts. In VST the counts are scaled such as to have the same amount of variance across all count magnitudes, effectively removing noise from the low counts.

## Raw counts

```{r correlations, fig.height=7, fig.width=8}
corels1 <- my_pairwise_internal_corels(method='spearman')
print( corels1[['combo1']] )
print( corels1[['act1']] )
```

## RPM counts

```{r correlations2, fig.height=7, fig.width=8}
corels2 <- my_pairwise_internal_corels(mat=rpm)
print( corels2[['combo1']] )
print( corels2[['act1']] )
```


## VST counts

```{r correlations3, fig.height=7, fig.width=8}
corels3 <- my_pairwise_internal_corels(mat = vstmat)
print( corels3[['combo1']] )
print( corels3[['act1']] )
```


# DE

The first subsection below contains static volcano and MA plots of *all the features*.

The second subsection contains interactive versions of these plots, filtered to show only the features that meet the thresholds. There you can hover over points to see their ID, zoom, etc.

The highlighted red triangles are the up to `r params$ntop` top hits out of all the points that meet the thresholds. This number limit is arbitrary. "Top-ness" of hits is heuristicaly ranked roughly based on their "distance" from the origin of the axes in the volcano plots.

If a contrast does not have any hits that meet the thresholds defined at the beginning of this report, a warning message will indicate that there are no hits, and there will be no highlighted points. The `r params$ntop` "top-est" points will still be listed in the table and shown in the interactive plots to satisfy your curiosity.

```{r DE}
resall <- NULL

# Build model
if (!is.null(params$reducedFormula)){
  deobj <- DESeq(deobj, test='LRT', reduced = as.formula(params$reducedFormula))  # LR test
} else {
  deobj <- DESeq(deobj) # Wald test
}
coeffs <- resultsNames(deobj)[resultsNames(deobj) != "Intercept"]
# Contrast against the assigned reference
resall <- lapply(coeffs, function(contrast) { message(contrast); do_de_plots(contrast) })
names(resall) <- vapply(resall, function(x) { x$contrast }, character(1))


if (length(cD) == 1 && params$roundrobin) {
  # Determine which was the reference and rotate each other level as reference.
  isref <- vapply(levels(cD[[1]]),
                   function(x) { all(grepl(x, coeffs[1]), grepl(x, coeffs[2])) },
                   logical(1) )
  ref <- levels(cD[[1]])[isref]
  remaining <- levels(cD[[1]])[!isref]
  for (lev in levels(cD[[1]])[!isref]) {
    # lev <- levels(cD[[1]])[!isref][1]
    deobj2 <- deobj
    deobj2[[names(cD)[1]]] <- relevel(deobj2[[names(cD)[1]]], ref= lev)
    if (!is.null(params$reducedFormula)){
      deobj2 <- DESeq(deobj2, test='LRT', reduced = as.formula(params$reducedFormula))  # LR test
    } else {
      deobj2 <- DESeq(deobj2) # Wald test
    }
    coeffs <- resultsNames(deobj2)[resultsNames(deobj2) != "Intercept"]
    resall2 <- lapply(coeffs, function(contrast) { message(contrast); do_de_plots(contrast, dds = deobj2) })
    names(resall2) <- vapply(resall2, function(x) { x$contrast }, character(1))
    resall <- c(resall, resall2)
  }
  
  # The rotation is brute-force-y and creates duplicate results A vs B and B vs A. Get rid of redundant contrasts.
  
  allcoeffs <- vapply(resall, function(x) { x$contrast }, character(1))
  # The reference condition shoud always be on the right-hand side of the VS.
  keep <- allcoeffs[!grepl(paste0(ref, "_vs"), allcoeffs)]
  # For the rest, either of each duplicate is fine. Let R create a vector of pairwise combinations.
  uniqcoeffs <- vapply(as.data.frame(combn(levels(cD[[1]]), 2), stringsAsFactors=FALSE),
                          function(x) { paste(names(cD)[1], x[2], "vs", x[1], sep="_") },
                          character(1) )
  uniqcoeffs <- uniqcoeffs[!grepl(ref, uniqcoeffs)] # already filtered the coefficients involving reference.
  keep <- keep[! keep %in% uniqcoeffs]
  resall <- resall[keep]
}
```

## Expression overview

Values are all increased by 1/10th of the smallest non-zero expression value, thus allowing zero values to be represented on log-scale.

When there are 2 or more replicates, the smaller plots on the right will show a 2D density of the mean-scaled StDev vs the mean expression. If there is only one replicate StDev cannot be calculated so, instead, the 1D density plot of the expression will be shown.

```{r expov, fig.height=8, fig.width=12}
pexp <- lapply (resall, function(res) {
  # res <- resall[[1]]
  DT <- res$outtab
  names(DT) <- vapply(strsplit(names(DT), '.', fixed=TRUE), function(x) x[4], character(1))
  DT[, colour := 'general']
  DT[is.na(padj), colour :='pNA']
  DT[name %in% res$tophits, colour := 'top']
  
  # Increment the 0z so they survive the log=transformation, but in a way they don;t mix with non-zero data.
  zeros <- min(DT[refMeanRPM > 0, refMeanRPM], DT[treatMeanRPM > 0, treatMeanRPM]) / 10
  cat(paste("zeros =", zeros))
  
  p1 <- ggplot(DT, aes(x=refMeanRPM + zeros, y=treatMeanRPM + zeros, colour=colour, label=name)) +
      # geom_point(data=DT[colour=='general', ], shape=16, alpha=0.3, size=0.8) +
      geom_hex(data=DT[colour=='general', ], size=0.5, colour='transparent', bins=100) +
      geom_point(data=DT[colour=='pNA', ], shape=20, alpha=0.2, size=0.8) +
      geom_abline(intercept = 0, slope = 1, colour='grey75', alpha=0.5) +
      geom_point(data=DT[colour=='top', ], shape=17, size=1.8) +
      geom_label_repel(data=DT[colour=='top', ], size=3, segment.size = 0.2,) +
      scale_colour_manual(values=c(general='black', top='red', pNA='steelblue')) +  
      scale_fill_gradient2(high='black') +
      scale_x_log10() + 
      scale_y_log10() +
      annotation_logticks(base=10, sides='lrtb') +
      labs(title=res$contrast) +
      theme(panel.grid.minor = element_blank(),
            legend.position='left') 
  
  # StDev is NA when there is only one replicate. So there are no values for Y-axis.
  if (!all( is.na(DT$refStDev) )) {
    p2 <- ggplot(DT, aes(x=refMeanRPM + zeros, y=(refStDev / refMeanRPM) + zeros, colour=colour)) +
        # geom_point(data=DT[colour=='black', ], shape=16, alpha=0.2, size=0.8) +
        geom_hex(data=DT[colour=='general', ], bins=50, size=0.5, colour='transparent') +
        geom_point(data=DT[colour=='pNA', ], shape=20, alpha=0.2, size=0.8) +
        geom_point(data=DT[colour=='top', ], shape=17, size=1.8) +
        scale_colour_manual(values=c(general='black', top='red', pNA='steelblue')) +  
        scale_fill_gradient2(high='black') +
        scale_x_log10() + 
        scale_y_log10() + 
        annotation_logticks(base=10, sides='lrtb') +
        # labs(title=res$contrast) +
        theme(panel.grid.minor = element_blank()) 
  } else {
    # Token blank plot, to maintain format.
    p2 <- ggplot(DT, aes(x=refMeanRPM + zeros, colour=colour)) +
      geom_density() +
      scale_colour_manual(values=c(general='black', top='red', pNA='steelblue')) +  
      scale_x_log10() + 
      annotation_logticks(base=10, sides='tb') +
      # labs(title=res$contrast) +
      theme(panel.grid.minor = element_blank()) 
  }
  
  # Again, StDev is NA when there is only one replicate.
  if (!all( is.na(DT$treatStDev) )) {
    p3 <- ggplot(DT, aes(x=treatMeanRPM + zeros, y=(treatStDev / treatMeanRPM) + zeros, colour=colour)) +
      # geom_point(data=DT[colour=='black', ], shape=16, alpha=0.2, size=0.8) +
      geom_hex(data=DT[colour=='general', ], bins=50, size=0.5, colour='transparent') +
      geom_point(data=DT[colour=='pNA', ], shape=20, alpha=0.2, size=0.8) +
      geom_point(data=DT[colour=='top', ], shape=17, size=1.8) +
      scale_colour_manual(values=c(general='black', top='red', pNA='steelblue')) +  
      scale_fill_gradient2(high='black') +
      scale_x_log10() + 
      scale_y_log10() + 
      annotation_logticks(base=10, sides='lrtb') +
      # labs(title=res$contrast) +
      theme(panel.grid.minor = element_blank())
  } else {
    # Token blank plot, to maintain format.
    p3 <- ggplot(DT, aes(x=treatMeanRPM + zeros, colour=colour)) +
      geom_density() +
      scale_colour_manual(values=c(general='black', top='red', pNA='steelblue')) +  
      scale_x_log10() + 
      annotation_logticks(base=10, sides='tb') +
      # labs(title=res$contrast) +
      theme(panel.grid.minor = element_blank()) 
  }
  
  print (p1 + (p2 / p3))
  return(p1 + (p2 / p3))
})
```

## Static Volcanos and MAs

```{r volcanos, fig.height=6, fig.width=12, warning=FALSE}
# These plots have two side-by-side facets and need more width to display nicely

for (res in resall){
  cat(res[["contrast"]])
  cat("\n")  
  print(res[["pv1"]])
  print(res[["pma1"]])
  cat("\n\n")  
}
```

## Interactive filtered Volcanos and MAs

```{r mas, fig.height=6, fig.width=7, warning=FALSE}
# These plots are not faceted, so need less width.

ly <- lapply(resall, function(res) {
  list(res[["pv2"]], res[["pma2"]])
})

htmltools::tagList(ly)
```

## Top hits

```{r hits, fig.height=10, fig.width=8, warning=FALSE}
allhits <- list()

for (res  in resall){
  # Are there any hits?
  # message(paste(res$contrast, res$hashits))
  if (res$hashits) {
    warning(paste("No hits meeting criteria in ", res$contrast,"! Listing outermost points instead."))
  }

  # Hit expression
  print(res[["pe1"]])

  # Hit list
  cat(res[["contrast"]])
  print(res[["tophits"]])
  allhits <- c(allhits, res[["tophits"]])

  cat("\n\n")
}
```

## Expression of all top hits

Top hits from all the individual comparisons.

```{r dexp, fig.height=15, fig.width=7}
allhits <- unique(unlist(allhits))

# Counts
mat1 <- vstmat[allhits, ]
mat2 <- rpm[allhits, ]

# Custer row and columns
cfit <- hclust(dist(scale(t(mat1), center=TRUE))) # cluster columns
rfit <- hclust(dist(scale(mat1, center=FALSE)))    # cluster rows
cn <- colnames(mat1)[cfit$order]
rn <- rownames(mat1)[rfit$order]

allhitdf <- as.data.table(mat2)
allhitdf[, Feature := rownames(mat2)]
allhitdf <- melt(allhitdf, value.name = "RPM", variable.name = "Sample", id.vars = "Feature")
allhitdf[, Feature := ordered(Feature, levels=rn)]
allhitdf[, Sample := ordered(Sample, levels=cn)]

pallexp <- ggplot(allhitdf, aes(y=Feature, x=Sample, fill=log10(RPM))) +
  geom_tile() +
  scale_fill_gradient(na.value='black') +
  labs(y='', x='') +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5, size=rel(1)),
        axis.text.y = element_text(size=rel(0.6)),
        panel.grid = element_blank())

allhitdf <- as.data.table(mat1)
allhitdf[, Feature := rownames(mat1)]
allhitdf <- melt(allhitdf, value.name = "VSTcounts", variable.name = "Sample", id.vars = "Feature")
allhitdf[, Feature := ordered(Feature, levels=rn)]
allhitdf[, Sample := ordered(Sample, levels=cn)]

pallvst <- ggplot(allhitdf, aes(y=Feature, x=Sample, fill=VSTcounts)) +
  geom_tile() +
  scale_fill_gradient(na.value='black') +
  labs(y='', x='') +
  theme(axis.text.x = element_text(angle=90, hjust = 1, vjust = 0.5, size=rel(1)),
        axis.text.y = element_text(size=rel(0.6)),
        panel.grid = element_blank())

print(pallexp)
print(pallvst)
```


# Files out

## Tables

```{r csv}
for (res in resall) {
fwrite(res$outtab,
         file = file.path(params$baseDir,
                          params$resultsDir,
                          paste(params$prefix, 
                                paste(sub('[^A-Za-z0-9_\\-.+~]', '-', design(deobj), perl=TRUE), 
                                      collapse=''), 
                                res$contrast, 
                                'deseq2.tsv', 
                                sep='.')),
         sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
}
```

## Plots to PDF

```{r pdf}
pdf(file.path(params$baseDir, 
              params$resultsDir, 
              paste(params$prefix, paste(sub('[^A-Za-z0-9_\\-.+~]', '-', design(deobj), perl=TRUE), collapse=''), 'deseq2.pdf', sep='.')),
    title=paste(params$prefix, paste(sub('[^A-Za-z0-9_\\-.+~]', '-', design(deobj), perl=TRUE), collapse=''), 'deseq2', sep='.'),
    width=15, height=15)

# Correlation plots
print(corels1[[1]] + labs(substitle='raw count'))
print(corels1[[2]] + labs(substitle='raw count'))
print(corels2[[1]] + labs(substitle='RPM'))
print(corels2[[2]] + labs(substitle='RPM'))
print(corels3[[1]] + labs(substitle='VST count'))
print(corels3[[2]] + labs(substitle='VST count'))

# DE plots
for (x in pexp) {
  print(x)
}
for (res in resall){
  # Static plots
  print(res[["pv1"]])
  print(res[["pma1"]])
  print(res[["pe1"]])
  print(res[["pe2"]])
}
print(pallexp)
print(pallvst)

dev.off()
```



# Session info

```{r}
sessionInfo()
```
