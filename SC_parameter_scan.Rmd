---
title: "Scan parameter space for single-cell sequencing dataset"
author: "Kimon"
date: "2/25/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r start}
library(Seurat)
library(ggplot2)
library(ggExtra)
library(patchwork)
library(dplyr)
library(tidyr)
# library(future)
require(cowplot)
require(ggrepel)

# plan("multiprocess", workers = 4)
# options(future.rng.onMisuse = "ignore")  #, future.globals.maxSize = 2000 * 1024^2)

datadirs <- c(control = '~/Desktop/markus_SC/control/raw_feature_bc_matrix/',
							Kdm2b = '~/Desktop/markus_SC/kdm2b/raw_feature_bc_matrix',
							Rc3h1 = '~/Desktop/markus_SC/Rc3h1/raw_feature_bc_matrix')

outdir <- '~/Desktop/markus_SC'
projectname = 'OT1_Kdm2b-Rc3h1_scan'

imported <- FALSE
filtered <- FALSE
ccadjusted <- FALSE
imported <- TRUE
filtered <- TRUE
ccadjusted <- TRUE

custom_filter <- FALSE
regress_cycle <- FALSE
custom_filter <- TRUE
regress_cycle <- TRUE
```



# Import data

```{r import}
if (!imported) {
	mincells = 3      # USER_INPUT
	minfeat = 200     # USER_INPUT

	message(paste('Data:', paste(datadirs, collapse=', ')))
	message(paste('Min # cells:', mincells))
	message(paste('Min # features per cell at import:', minfeat))

	# Import data pre-processed with 10X CellRanger
	CR <- Read10X(data.dir=datadirs, gene.column=2, unique.features=TRUE, strip.suffix = TRUE) 
	
	# Create seurat object.
	# Inconsistent nesting structure created by Read10X. If multiple measurement types are integrated, there is an extra nesting layer, that is not kept when there is only one measurement type.
	if ('Gene Expression' %in% names(CR)){
		# Multiple measurement types (ie, RNA and protein) in the imported data
		so <- CreateSeuratObject(counts = CR[`Gene Expression`], 
														 min.cells=mincells, project=projectname, min.features=minfeat)
	} else {
		# Just a single measurement type (probably "Gene Expression" ?)
		so <- CreateSeuratObject(counts = CR, min.cells=mincells, project=projectname, min.features=minfeat)
	}
	
	so@meta.data[["Source"]] = so@meta.data[["orig.ident"]]
	
	# Checkpoint.
	saveRDS(so, file = file.path(outdir, paste0(projectname, '_imported.RDS')))
	imported <- TRUE
	
} else {
	
	so <- readRDS(file = file.path(outdir, paste0(projectname, '_imported.RDS')))
}

print( so )
```



# QC

## Summary

```{r qc_input, fig.width=15, fig.height=15}
plot_number_of_features <- function(DF = so@meta.data) {
		p1 <- ggplot(DF,
					 aes(x=Source, y=nFeature_RNA, fill=Source)) +
			geom_jitter(width=0.3, height=0, size=rel(0.5), shape=16, alpha=0.4, colour='grey50') +
			geom_violin(draw_quantiles=c(0.25, 0.5, 0.75), colour='black', alpha=0.2, size=rel(0.5)) +
			coord_cartesian(ylim=c(0,NA)) +
			guides(colour=FALSE) +
			labs(x=NULL, y=NULL, title='# of Genes') +
			theme_light() + 
			theme(axis.text.x=element_text(angle=45, hjust=1, vjust=1),
						legend.position='none')
		
		p2 <- ggplot(DF,
					 aes(x=Source, y=nCount_RNA, fill=Source)) +
			geom_jitter(width=0.3, height=0, size=rel(0.5), shape=16, alpha=0.4, colour='grey50') +
			geom_violin(draw_quantiles=c(0.25, 0.5, 0.75), colour='black', alpha=0.2, size=rel(0.5)) +
			coord_cartesian(ylim=c(0,NA)) +
			guides(colour=FALSE) +
			labs(x=NULL, y=NULL, title='# of Molecules') +
			theme_light() + 
			theme(axis.text.x=element_text(angle=45, hjust=1, vjust=1),
						legend.position='none')
		
		p3 <- ggplot(DF,
					 aes(x=Source, y=percent.mt, fill=Source)) +
			# geom_hline(yintercept=10, colour='red') +
			geom_jitter(width=0.3, height=0, size=rel(0.5), shape=16, alpha=0.4, colour='grey50') +
			geom_violin(draw_quantiles=c(0.25, 0.5, 0.75), colour='black', alpha=0.2, size=rel(0.5)) +
			coord_cartesian(ylim=c(0,NA)) +
			guides(colour=FALSE) +
			labs(x=NULL, y=NULL, title='% of Mt contamination') +
			theme_light() + 
			theme(axis.text.x=element_text(angle=45, hjust=1, vjust=1),
						legend.position='none')
		
		return( list(p1, p2, p3) )
	}

plot_qc_correlations <- function(DF=so@meta.data){
		n <- unique(DF$Source)
		DF$Source <- factor(DF$Source, ordered=TRUE, labels=n)
		
		featcor <- function(f1='nFeature_RNA', f2='percent.mt'){
			paste(vapply(n, function(x) {
							sel <- DF$Source %in% x
							round(cor(DF[, f1][sel], DF[, f2][sel]), 2)
						}, numeric(1)),
						collapse=', ')
		}
		
		p1 <- ggplot(DF,
					 aes(x=nFeature_RNA, y=percent.mt, colour=Source)) +
			facet_grid( . ~ Source) +
			geom_point(shape=16, alpha=0.5, size=rel(0.5)) +
			scale_colour_discrete(name='Sample', guide='none') + 
			guides(colour='none') +
			coord_cartesian(ylim=c(0,NA), xlim=c(0,NA)) +
			labs(x='# of Genes', y='% of Mt contamination', title='Correlation', subtitle=featcor('nFeature_RNA', 'percent.mt')) +
			theme_classic() + 
			theme(axis.text.x=element_text(angle=90, hjust=0.5, vjust=1))
		
		p2 <- ggplot(DF,
					 aes(x=nCount_RNA, y=percent.mt, colour=Source)) +
			facet_grid( . ~ Source) +
			geom_point(shape=16, alpha=0.5, size=rel(0.5)) +
			scale_colour_discrete(name='Sample', guide='none') + 
			guides(colour='none') +
			coord_cartesian(ylim=c(0,NA), xlim=c(0,NA)) +
			labs(x='# of Molecules', y='% of Mt contamination', title='Correlation', subtitle=featcor('nCount_RNA', 'percent.mt')) +
			theme_classic() + 
			theme(axis.text.x=element_text(angle=90, hjust=0.5, vjust=1))
		
		p3 <- ggplot(DF,
					 aes(x=nCount_RNA, y=nFeature_RNA, colour=Source)) +
			facet_grid( . ~ Source) +
			geom_point(shape=16, alpha=0.5, size=rel(0.5)) +
			scale_colour_discrete(name='Sample', guide='none') + 
			coord_cartesian(ylim=c(0,NA), xlim=c(0,NA)) +
			labs(x='# of Molecules', y='# of Genes', title='Correlation', subtitle=featcor('nFeature_RNA', 'nCount_RNA')) +
			theme_classic() + 
			theme(axis.text.x=element_text(angle=90, hjust=0.5, vjust=1))
		
		
		return( list(p1, p2, p3) )
}

if (!filtered) {
	
	## The number of unique genes and total molecules are automatically calculated during CreateSeuratObject
	
	# Contamination with mitochondrial genes
	so[['percent.mt']] <- PercentageFeatureSet(so, pattern='^MT-|^mt-|^Mt-')
	
	# Count summaries.
	for (s in unique(so@meta.data$Source)){
		message(s)
		print( summary(so@meta.data[so@meta.data$Source==s, c('nFeature_RNA', 'nCount_RNA', 'percent.mt')]) )
	}
	
	l <- plot_number_of_features(so@meta.data)
	print( l[[1]] + l[[2]] + l[[3]] + plot_layout(guides='collect'))
	
	# Correlations. Only number of molecules and number of genes should correlate.
	l <- plot_qc_correlations(so@meta.data)
	print( l[[1]] + l[[2]] + l[[3]] + plot_layout(guides='collect'))
	
}
```

```{r qc_filter}
if (!filtered) {
	
	# Remove unwanted cells
	minfeat <- 1000    # USER-INPUT
	maxfeat <- 6000    # USER-INPUT
	maxmt <- 10        # USER-INPUT
	
	message(paste('Selected lower threshold:', minfeat, 'features'))
	message(paste('Selected upper cutoff:', maxfeat, 'features'))
	message(paste('Max mitochondrial contamination allowed:', maxmt, '%'))
	
	so <- subset(so, subset = nFeature_RNA > minfeat & nFeature_RNA < maxfeat & percent.mt < maxmt)
	
	# Don't save here. Save after scaling the data.
	# saveRDS(so, file = file.path(outdir, paste0(projectname, '_filtered.RDS')))
	# filtered <- TRUE
	
} else {
	
	message("Using pre-processed data that's already filtered.")
	so <- readRDS(file = file.path(outdir, paste0(projectname, '_filtered.RDS')))
}
```

## Filtered summary

```{r qc_filtered, fig.width=15, fig.height=15}
# Count summaries.
for (s in unique(so@meta.data$Source)){
	message(s)
	print( summary(so@meta.data[so@meta.data$Source==s, c('nFeature_RNA', 'nCount_RNA', 'percent.mt')]) )
}
	
l <- plot_number_of_features(so@meta.data)
print( l[[1]] + l[[2]] + l[[3]] + plot_layout(guides='collect'))

l <- plot_qc_correlations(so@meta.data)
print( l[[1]] + l[[2]] + l[[3]] + plot_layout(guides='collect'))
```

```{r scale}
# Cell cycle genes.            # USER_INPUT
# Mouse, compiled by Markus
s.genes <- c('Mcm4','Exo1','Slbp','Gmnn','Cdc45','Msh2','Mcm6','Rrm2','Pold3','Blm','Ubr7','Mcm5','Clspn','Hells',
						 'Nasp','Rpa2','Rad51ap1','Tyms','Rrm1','Rfc2','Prim1','Brip1','Usp1','Ung','Pola1','Mcm2','Fen1','Tipin',
						 'Pcna','Cdca7','Uhrf1','Casp8ap2','Cdc6','Dscc1','Wdr76','E2f8','Dtl','Ccne2','Atad2','Gins2','Chaf1b',
						 'Pcna-ps2')       
g2m.genes <- c('Nuf2','Psrc1','Ncapd2','Ccnb2','Smc4','Lbr','Tacc3','Cenpa','Kif23','Cdca2','Anp32e','G2e3','Cdca3',
							 'Anln','Cenpe','Gas2l3','Tubb4b','Cenpf','Dlgap5','Hjurp','Cks1brt','Gtse1','Bub1','Birc5','Ube2c',
							 'Rangap1','Hmmr','Ect2','Tpx2','Ckap5','Cbx5','Nek2','Ttk','Cdca8','Nusap1','Ctcf','Cdc20','Cks2',
							 'Mki67','Tmpo','Ckap2l','Aurkb','Kif2c','Cdk1','Kif20b','Top2a','Aurka','Ckap2','Hmgb2','Cdc25c',
							 'Ndc80','Kif11')

if (!filtered){
	normscalefactor=1e6    # USER-INPUT

	# Normalize counts across cells
	message(paste('Log-normalization to:', normscalefactor))
	so <- NormalizeData(so, normalization.method = "LogNormalize", scale.factor = normscalefactor)
	
	# Standardize expressions for PCA
	so <- ScaleData(so, features = rownames(so))
	
	# Identify cell cycle phase of each cell
	if (!is.null(s.genes) && !is.null(g2m.genes)) {
		so <- CellCycleScoring(so, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)
		so$CC.Difference <- so$S.Score - so$G2M.Score
	}
	
	if (!custom_filter) {
		# Checkpoint.
		saveRDS(so, file = file.path(outdir, paste0(projectname, '_filtered.RDS')))
		filtered <- TRUE
	}
}
```

```{r qc_cc}
# CC phase summary
for (s in unique(so@meta.data$Source)){
	message(s)
	print( summary(so@meta.data[so@meta.data$Source==s, c('Source', 'Phase')]) )
}
```

## Custom filter

```{r custom_filter, fig.width=15, fig.height=15}
if (!custom_filter) {
	
	message("No additional filtering specified.")
	
} else {
	
	if (!filtered) {
		print( VlnPlot(so, features=c('Cd3d'), group.by='Source') )     # USER-INPUT
		so <- subset(so, Cd3d > 2.5)                                    # USER-INPUT
	}
	print( VlnPlot(so, features=c('Cd3d'), group.by='Source') )       # USER-INPUT
	
	# Checkpoint.
	saveRDS(so, file = file.path(outdir, paste0(projectname, '_filtered.RDS')))
	filtered <- TRUE
	
	# Count summaries.
	for (s in unique(so@meta.data$Source)){
		message(s)
		print( summary(so@meta.data[so@meta.data$Source==s, c('nFeature_RNA', 'nCount_RNA', 'percent.mt')]) )
	}
		
	l <- plot_number_of_features(so@meta.data)
	print( l[[1]] + l[[2]] + l[[3]] + plot_layout(guides='collect'))
	
	l <- plot_qc_correlations(so@meta.data)
	print( l[[1]] + l[[2]] + l[[3]] + plot_layout(guides='collect'))
	
	for (s in unique(so@meta.data$Source)){
		message(s)
		print( summary(so@meta.data[so@meta.data$Source==s, c('Source', 'Phase')]) )
	}
}
```

## Adjust for Cell Cycle

```{r cc, warning=FALSE, fig.width=8, fig.height=8}
if (regress_cycle) {
	if (!ccadjusted) {
		
		# Find variable features. 
		# The selection of features is not used here, but this is needed for the side-effect of calculating the variances.
		so <- FindVariableFeatures(so, selection.method = "vst")
		
		# PCA on CC genes
		so <- RunPCA(so, features = c(s.genes, g2m.genes))
		
		p1 <- DimPlot(so, reduction = "pca", dims=c(1,2), pt.size = 0.1, group.by='Phase') +
						coord_fixed(ratio=1) +
						theme_light() +
						theme(panel.grid=element_blank())
		p2 <- DimPlot(so, reduction = "pca", dims=c(1,3), pt.size = 0.1, group.by='Phase') +
						coord_fixed(ratio=1) +
						theme_light() +
						theme(panel.grid=element_blank())
		p3 <- DimPlot(so, reduction = "pca", dims=c(2,3), pt.size = 0.1, group.by='Phase') +
						coord_fixed(ratio=1) +
						theme_light() +
						theme(panel.grid=element_blank())
		
		print( ggMarginal(p1, groupColour=TRUE) )
		print( ggMarginal(p2, groupColour=TRUE) )
		print( ggMarginal(p3, groupColour=TRUE) )
		
		# This takes a long time, maybe even an hour.
		so <- ScaleData(so, vars.to.regress = c("S.Score", "G2M.Score"), features = rownames(so))  # Completely remove cycle.
		# so <- ScaleData(so, vars.to.regress = "CC.Difference", features = rownames(so))          # Remove phases, but separate cycling from non-cycling.
		
		# Checkpoint
		saveRDS(so, file = file.path(outdir, paste0(projectname, '_ccadjusted.RDS')))
		ccadjust <- TRUE
		
	} else {
		
		message("Using pre-processed data that is already adjusted.")
		so <- readRDS(file = file.path(outdir, paste0(projectname, '_ccadjusted.RDS')))
	}
	
	so <- RunPCA(so, features = c(s.genes, g2m.genes))
	
	p1 <- DimPlot(so, reduction = "pca", dims=c(1,2), pt.size = 0.1, group.by='Phase') +
						coord_fixed(ratio=1) +
						theme_light() +
						theme(panel.grid=element_blank())
	p2 <- DimPlot(so, reduction = "pca", dims=c(1,3), pt.size = 0.1, group.by='Phase') +
					coord_fixed(ratio=1) +
					theme_light() +
					theme(panel.grid=element_blank())
	p3 <- DimPlot(so, reduction = "pca", dims=c(2,3), pt.size = 0.1, group.by='Phase') +
					coord_fixed(ratio=1) +
					theme_light() +
					theme(panel.grid=element_blank())
	
	print( ggMarginal(p1, groupColour=TRUE) )
	print( ggMarginal(p2, groupColour=TRUE) )
	print( ggMarginal(p3, groupColour=TRUE) )
}
```



# Parameter scan

```{r scan}
nvariables <- c(50, 100, 250, 500, 1000, 2000)
dimlim <- c(5, 10, 15, 20, 35, 50)
nneighbours <- c(5, 10, 30, 50)
mindist <- c(0.001, 0.01, 0.05, 0.1, 0.3, 0.5)

scree <- function (so) {
	pc_vars <- Stdev(object = so, reduction = 'pca') ^ 2  # From stdevs to % of total variance.
	pc_vars <- 100 * pc_vars / sum(pc_vars)
	ndims <- length(pc_vars)
	fewerdims <- min(50, ndims)
	
	p1 <- ggplot(data = data.frame(PC = 1:ndims, var = pc_vars),
				 aes(x=PC, y=var)) +
	    geom_bar(stat='identity', width=0.5) +
			geom_text(aes(label=round(var,2), y=var + (0.02 * max(pc_vars)), x=PC), angle=90, hjust=0, size=rel(2.2)) +
			coord_cartesian(ylim=c(0, 1.1 * max(pc_vars))) +
			scale_y_continuous(expand=c(0,0)) +
	    labs(x='PC', y='% Variance') +
		  theme_classic()
	
	return( p1 )
}

message(file.path(outdir, paste0(projectname, '_parameter-scan.pdf')))

pdf(file=file.path(outdir, paste0(projectname, '_parameter-scan.pdf')))

for (nv in nvariables) {
	# nv <- nvariables[1]
	
	# Variables
	so <- FindVariableFeatures(so, selection.method = "vst", nfeatures = nv)
	top1 <- head( VariableFeatures(so), 1)
	print( LabelPoints(plot = VariableFeaturePlot(so), points = top1, repel=TRUE) )
	ndims <- length(Stdev(so))
	
	# PCA
	so <- RunPCA(so, features = VariableFeatures(so))
	print( scree(so) + labs(title=nv) )
	p1 <- DimPlot(so, reduction = "pca", dims=c(1,2), pt.size = 0.01, group.by='Source') +
				 	coord_fixed(ratio=1) +
					labs(title=NULL) +
					theme_light() +
					theme(panel.grid=element_blank())
	p2 <- DimPlot(so, reduction = "pca", dims=c(1,3), pt.size = 0.01, group.by='Source') +
				 	coord_fixed(ratio=1) +
					labs(title=NULL) +
					theme_light() +
					theme(panel.grid=element_blank())
	p3 <- DimPlot(so, reduction = "pca", dims=c(2,3), pt.size = 0.01, group.by='Source') +
				 	coord_fixed(ratio=1) +
					labs(title=NULL) +
					theme_light() +
					theme(panel.grid=element_blank())
	print( (p1 + labs(subtitle=nv)) + p2 + p3 + plot_layout(guides='collect'))

	# UMAP
	for (dl in unique(c(dimlim[dimlim <= ndims], ndims))) {
		for (nn in nneighbours){
			message(paste(nv,dl,nn))
			l <- lapply( mindist, function(md){
							so <- RunUMAP(so, dims=1:dl, n.neighbors=nn, min.dist=md)
							p1 <- DimPlot(so, reduction='umap', group.by='Source', pt.size=0.01) +
								labs(title=NULL, x=NULL, y=NULL, subtitle=paste0('V',nv, ' D', dl, ' N', nn, ' d', md)) +
								coord_fixed(ratio=1) +
								theme_light() +
								theme(panel.grid=element_blank())
							return( p1 )
			})
			
			print( Reduce(`+`, l) + plot_layout(guides='collect') )
		}
	}
}

dev.off()
```




# Session

```{r session}
sessionInfo()
```
