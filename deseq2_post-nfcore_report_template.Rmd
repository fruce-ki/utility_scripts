---
title: "Differential Abundance Quick View"
author: "Kimon Froussios"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_float:
      collapsed: false
params:
  comparison: time_W6_vs_W3.conf_condition                # name of a specific comparison for this report
  da_path: /SCRATCH/PP2023011_SLC13A5/tesslinz_diffex                           # output dir of nf-core/differentialabundance
  counts: /SCRATCH/PP2023011_SLC13A5/tesslinz.salmon.merged.gene_counts.tsv     # file of raw counts
  tpm: /SCRATCH/PP2023011_SLC13A5/tesslinz.salmon.merged.gene_tpm.tsv           # file of TPM counts
  covars: /SCRATCH/PP2023011_SLC13A5/samplesheet_tesslinz.differentialabundance.csv  # samplesheet file for nf-core/differentialabundance
  genesets: ['/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/h.all.v2023.2.Hs.symbols.gmt', '/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/c5.hpo.v2023.2.Hs.symbols.gmt', '/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/c5.go.mf.v2023.2.Hs.symbols.gmt', '/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/c5.go.bp.v2023.2.Hs.symbols.gmt', '/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/c2.cp.kegg_medicus.v2023.2.Hs.symbols.gmt', '/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/c2.cp.reactome.v2023.2.Hs.symbols.gmt', '/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/c2.cp.wikipathways.v2023.2.Hs.symbols.gmt', '/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/c2.cp.pid.v2023.2.Hs.symbols.gmt', '/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/c2.cp.biocarta.v2023.2.Hs.symbols.gmt', '/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/c3.tft.gtrd.v2023.2.Hs.symbols.gmt', '/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/c3.tft.tft_legacy.v2023.2.Hs.symbols.gmt', '/SCRATCH/REFERENCES/msigdb_v2023.2.Hs_GMTs/c1.all.v2023.2.Hs.symbols.gmt']
  highlight_n: 50       # number of DE genes to highlight
  min_count: 10         # minimum raw count for DE to be accapted
  min_tpm: 5            # minimum TPM for DE to be accepted
  min_lfc: 1            # minimum log2 fold-change  for DE to be accepted
  max_q: 0.05           # FDR level for DE and GSEA
  genelist : ''         # optional file with custom gene list to highlight instead of DE
  pad: true             # pad zero counts for plots (otherwise the log-scaled axes hide the non-expressed genes)
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, bitmapType='cairo-png')
```

# Setup

```{r libraries, message=FALSE}

setwd(params$da_path)

library(data.table)
library(ggplot2)
library(patchwork)
library(ggrepel)
library(DT)
library(DESeq2)
library(fgsea)
library(stringr)
library(parallel)

# ggplot2 base theme
theme_set(theme_bw())

# data.table::setDTthreads(1L)
threads <- min(c(length(params$genesets), detectCores()))

options(scipen=200)
```

```{r load}

# Combine inputs 
munge_DE_tables <- function(deseq, shrink, counts, tpm, normcounts, vst, covars, 
                            subsamples, mainvar, varref, vartreat,
                            min_count = 50, min_tpm = 5, min_lfc = 0.5, max_q = 0.05,
                            highlight_n = 50, genelist = NULL, pad = TRUE) {
  
  shrink <- data.table(gene_id = rownames(shrink), shrunkLFC = shrink$log2FoldChange)
  deseq <- merge(deseq, shrink, by = 'gene_id')
  
  # DE filters
  deseq[, fltr_fdr_pass := padj < max_q] # this also covers NA (ie genes not tested due to failing deseq filtering)
  deseq[, fltr_lfc_pass := abs(log2FoldChange) >= min_lfc]
  deseq[, fltr_de_pass := fltr_fdr_pass & fltr_lfc_pass]
  ## Home-brewed selection of top hits to highlight, by euclidean distance from origin.
  # It mostly works OK, but the selection should not be taken as gospel.
  # Down-weight mlog10p for a more balanced selection not dominated by p value.
  pbias <- 0.75    # bias the point selection to slightly prioritize pvalue over fold-change (< 1) or vice verse (> 1)
  deseq[, mlog10p := -log10(padj)]
  deseq[, absl2fc := abs(shrunkLFC)]
  ppen <- max(deseq$mlog10p[is.finite(deseq$mlog10p)]) / max(deseq$absl2fc[is.finite(deseq$absl2fc)]) * pbias     # scaling factor determined by axes ranges
  deseq[, radius := sqrt((mlog10p / ppen) ^ 2 + absl2fc ^ 2)]
  deseq[, rank := rank(-radius, ties.method = 'average', na.last = TRUE)]
  deseq[, absl2fc := NULL]
  deseq[, mlog10p := NULL]
  
  # Big table of counts of relevant samples
  DTc <- melt(counts[, names(counts) %in% c('gene_id', 'gene_name', subsamples) , with = FALSE], 
              id.vars = c('gene_id', 'gene_name'), variable.name = 'sample', value.name = 'raw')
  setkey(DTc, gene_id)
  DTt  <- melt(tpm[, names(tpm) %in% c('gene_id', subsamples) , with = FALSE], 
              id.vars = c('gene_id'), variable.name = 'sample', value.name = 'tpm')
  setkey(DTt, gene_id)
  DTn <- melt(normcounts[, names(normcounts) %in% c('gene_id', subsamples) , with = FALSE], 
              id.vars = c('gene_id'), variable.name = 'sample', value.name = 'normalised')
  setkey(DTn, gene_id)
  DTv <- melt(vst[, names(vst) %in% c('gene_id', subsamples) , with = FALSE], 
              id.vars = c('gene_id'), variable.name = 'sample', value.name = 'vst')
  setkey(DTv, gene_id)
  DT <- Reduce(function(x, y){ merge(x, y, by = c('gene_id', 'sample'), all = TRUE)}, 
               list(DTc, DTt, DTn, DTv) )
  DT <- melt(DT, id.vars = c('gene_id', 'gene_name', 'sample'), variable.name = 'count_type', value.name = 'abundance')
  
  # Add DE
  DT <- merge(DT, deseq, by = 'gene_id', all.x = TRUE)
  # Add sample metadata
  DT <- merge(DT, covars, by = 'sample', all.x = TRUE)

  if (pad) {
    # Pad zeros, in a non-interfering way.
    rawpad <- min(DT[count_type == 'raw' & abundance > 0, abundance], na.rm = TRUE) / 5
    DT[count_type == 'raw', abundance := abundance + rawpad]
    message('Zero-padding the raw counts by ', rawpad)
    tpmpad <- min(DT[count_type == 'tpm' & abundance > 0, abundance], na.rm = TRUE) / 5
    DT[count_type == 'tpm', abundance := abundance + tpmpad]
    message('Zero-padding the TPMs by ', tpmpad)
    message('The pad values are selected sufficiently small to avoid interference with non-zero measurements.')
  }
  
  ## Abundance filters
  DT <- DT[count_type == 'raw' & mainvar == 'reference', condGeneMean := mean(.SD$abundance), by = gene_id]
  DT <- DT[count_type == 'raw' & mainvar == 'target', condGeneMean := mean(.SD$abundance), by = gene_id]
  DT <- DT[count_type == 'tpm' & mainvar == 'reference', condGeneMean := mean(.SD$abundance), by = gene_id]
  DT <- DT[count_type == 'tpm' & mainvar == 'target', condGeneMean := mean(.SD$abundance), by = gene_id]
  DT <- DT[count_type == 'normalised' & mainvar == 'reference', condGeneMean := mean(.SD$abundance), by = gene_id]
  DT <- DT[count_type == 'normalised' & mainvar == 'target', condGeneMean := mean(.SD$abundance), by = gene_id]
  DT <- DT[count_type == 'vst' & mainvar == 'reference', condGeneMean := mean(.SD$abundance), by = gene_id]
  DT <- DT[count_type == 'vst' & mainvar == 'target', condGeneMean := mean(.SD$abundance), by = gene_id]
  
  DT <- DT[count_type == 'raw', fltr_geneMean_pass := condGeneMean >= min_count]        # separately for each condition and count type
  DT <- DT[count_type == 'tpm', fltr_geneMean_pass := condGeneMean >= min_tpm]
  DT <- DT[, fltr_abund_pass := any(.SD[count_type == 'raw', fltr_geneMean_pass]) & any(.SD[count_type == 'tpm', fltr_geneMean_pass]), by = gene_id]  # aggregate: either condition, for both count types
  
  # Eliminate NAs in booleans
  DT[is.na(fltr_fdr_pass), fltr_fdr_pass := FALSE]                                # Genes that weren't tested due to failing deseq2 abundance filter
  DT[is.na(fltr_lfc_pass), fltr_lfc_pass := FALSE]                                # 
  DT[is.na(fltr_de_pass), fltr_de_pass := FALSE]                                  # still the same genes as above
  
  # Master filter
  DT[, fltr_pass := fltr_abund_pass & fltr_de_pass]
  
  # Add highlight selection
  if (!is.null(genelist)) {
    markgenes <- fread(genelist)[[1]]
    warning('Highlighting a custom list of genes. The quoted selection thresholds do not apply!')
  } else {
    setorder(DT, rank)
    markgenes <- head(unique(DT[(fltr_pass), gene_id]), highlight_n)
    if (length(markgenes) <= 1) {                                                                       # if there isn't much to show
      markgenes <- head(unique(DT[, gene_id]), highlight_n)         # add some context of the nearest misses
    }
  }
  DT[, mark := gene_id %in% markgenes] 
  
  # Fix order, for plot facets 
  DT[, count_type := factor(count_type, levels = c('raw', 'tpm', 'normalised', 'vst'), ordered = TRUE)]
  setkey(DT, gene_id, count_type, mainvar, sample)
  
  return(list(DT = DT, deseq = deseq))
}



# Contrast
stopifnot(str_detect(params$comparison, '\\w+_\\w+_vs_\\w+'))
contrast <- str_split(str_extract(params$comparison, '\\w+_\\w+_vs_\\w+'), '_')[[1]]
mainvar <- contrast[1]
vartreat <- contrast[2]
varref <- contrast[4]

# INPUTS
dds <- readRDS(file.path(params$da_path, 'other', 'deseq2', paste0(params$comparison, '.dds.rld.rds')))         # can't shrink LFC otherwise
deseq <- fread(file.path(params$da_path, 'tables', 'differential', paste0(params$comparison, '.deseq2.results.tsv')))  # to avoid running it with different parameters than the pipeline
vst <- fread(file.path(params$da_path, 'tables', 'processed_abundance', 'all.vst.tsv'))
normcounts <- fread(file.path(params$da_path, 'tables', 'processed_abundance', 'all.normalised_counts.tsv'))
counts <- fread(params$counts)
tpm <- fread(params$tpm)
  
# Metadata
covars <- as.data.table(colData(dds))
# Make generic name for coding ease
covars[, mainvar := covars[[mainvar]]]
covars[mainvar == varref, mainvar := 'reference']
covars[mainvar == vartreat, mainvar := 'target']

# Relevant samples
subsamples <- covars$sample
if(str_detect(params$comparison, '\\w+_\\w+\\.\\w+_\\w+_vs_\\w+')) {
  selection <- str_split(str_extract(params$comparison, '^\\w+_\\w+'), '_')[[1]]
  selvar <- selection[1]
  selval <- selection[2]
  subsamples <- covars$sample[covars[[selvar]] == selval]
}
covars <- covars[sample %in% subsamples, ]
# Excluded due to sequencing QC or other external reasons
if ('use' %in% names(covars) && is.logical(covars$use)) {
  subsamples <- covars[(use), sample]
  covars <- covars[sample %in% subsamples, ]
}

# Shrunken LFC
shrink <- lfcShrink(dds, type ='ashr', contrast = c(mainvar, vartreat, varref),      # apeglm doesn't like this format of contrast specification
                    res = results(dds, contrast = c(mainvar, vartreat, varref), alpha = params$max_q, lfcThreshold = 0, independentFiltering = TRUE))

# Custom highlights
genelist <- NULL
if (!is.null(params$genelist) && params$genelist != '' && params$genelist != 'NULL'){
  genelist <- fread(params$genelist)
}
  

munged <- munge_DE_tables(deseq = deseq, shrink = shrink, counts = counts, tpm = tpm, normcounts = normcounts, vst = vst, covars = covars, 
                            subsamples = subsamples, mainvar = mainvar, varref = varref, vartreat = vartreat,
                            min_count = params$min_count, min_tpm = params$min_tpm, min_lfc = params$min_lfc, max_q = params$max_q,
                            highlight_n = params$highlight_n, genelist = genelist, pad = params$pad)
DT <- munged$DT
deseq <- munged$deseq


saveRDS(DT, file = file.path(params$da_path, 'tables', 'differential', paste0(params$comparison, '.diffex_extra.RDS')))
```



# Contrast and Variables

```{r name}
cat('\n###\nContrast name:\n\n', params$comparison, '\n')

cat('\n###\nMetadata of the relevant samples:\n')
datatable(covars[sample %in% subsamples,], options = list(pageLength = min(25, nrow(covars))))
```



# Differential abundance

## FC & significance

`fltr_pass` represents genes that meet all of the criteria: FDR < `r params$max_q` , abs(L2FC) > `r params$min_lfc`, mean raw count in at least one condition > `r params$min_count`, and mean TPM in at least one condition > `r params$min_tpm`.

```{r volcano, fig.height=15, fig.width=15}
volcXY <- unique(DT[, .(gene_id, gene_name, padj, log2FoldChange, shrunkLFC, fltr_abund_pass, fltr_de_pass, fltr_pass, mark)])
volcXY[, upregulated := log2FoldChange > 0]
volcXY[log2FoldChange == 0, upregulated := NA] # edge case

desummary <- as.data.table(table(volcXY[, .(fltr_pass, upregulated)]))
desummary[as.logical(upregulated), DE := 'up']
desummary[!as.logical(upregulated), DE := 'down']
desummary[, upregulated := NULL]
setnames(desummary, c('fltr_pass', 'N_genes', 'Diff'))
setorder(desummary, fltr_pass)

print(desummary)

p_volcano <- ggplot(volcXY, aes(x = log2FoldChange, y = -log10(padj), colour = fltr_pass, label = gene_name)) +
  geom_point(data = volcXY[(!fltr_pass)], shape = 16, size = rel(0.8), alpha = 0.7) +
  geom_point(data = volcXY[(fltr_pass)], shape = 16, size = rel(1)) +
  geom_label_repel(data = volcXY[(mark), ], colour = 'black', min.segment.length = 0, segment.size = 0.3, size = rel(2.5), force = 2, force_pull = 0.1, max.overlaps = 100) +
  scale_colour_manual(values = c('grey50', '#2244FF')) +
  labs(title = params$comparison) +
  theme(legend.position = 'bottom')

p_volcano
```

```{r shrunkvolcano, fig.height=15, fig.width=15}
# p_shrunkvolcano <- ggplot(volcXY, aes(x = shrunkLFC, y = -log10(padj), colour = fltr_pass, label = gene_name)) +
#   geom_point(data = volcXY[(!fltr_pass)], shape = 16, size = rel(0.8), alpha = 0.7) +
#   geom_point(data = volcXY[(fltr_pass)], shape = 16, size = rel(1)) +
#   geom_label_repel(data = volcXY[(mark), ], colour = 'black', min.segment.length = 0, segment.size = 0.3, size = rel(2.5), force = 2, force_pull = 0.1, max.overlaps = 100) +
#   scale_colour_manual(values = c('grey50', '#2244FF')) +
#   labs(title = params$comparison) +
#   theme(legend.position = 'bottom')
# 
# p_shrunkvolcano
```

## FC & abundance

```{r ma, fig.height=15, fig.width=15}
maXY <- unique(DT[mainvar == 'reference' & count_type == 'normalised', .(gene_id, gene_name, count_type, condGeneMean, log2FoldChange, fltr_pass, mark)])

p_ma <- ggplot(maXY, aes(x = condGeneMean, y = log2FoldChange, colour = fltr_pass, label = gene_name)) +
  facet_wrap(~ count_type, scales = 'free', ncol = 1) +
  geom_point(data = maXY[(!fltr_pass)], shape = 16, size = rel(0.8), alpha = 0.7) +
  geom_hline(yintercept = 0, linetype = 'dashed') +
  geom_point(data = maXY[(fltr_pass)], shape = 16, size = rel(1)) +
  geom_label_repel(data = maXY[(mark), ], colour = 'black', min.segment.length = 0, segment.size = 0.3, size = rel(2), force = 2, force_pull = 0.1, max.overlaps = 100) +
  scale_x_log10() +
  scale_colour_manual(values = c('grey50', '#2244FF')) +
  labs(title = params$comparison, x = 'Reference abundance') +
  theme(legend.position = 'bottom')

p_ma
```

## Mean abundances

`fltr_pass` represents genes that meet all of the criteria: FDR < `r params$max_q` , abs(L2FC) > `r params$min_lfc`, mean raw count in at least one condition > `r params$min_count`, and mean TPM in at least one condition > `r params$min_tpm`.

```{r expression, fig.height=15, fig.width=15}
abundXY <- dcast(unique(DT[count_type == 'tpm', .(gene_id, gene_name, count_type, condGeneMean, fltr_abund_pass, fltr_de_pass, fltr_pass, mark, mainvar)]), '... ~ mainvar', value.var = 'condGeneMean')

p_XY <- ggplot(abundXY, aes(x = reference, y = target, label = gene_name, colour = fltr_pass)) +
  facet_wrap(~ count_type, scales='free', ncol = 1) +
  geom_point(data = abundXY[!(fltr_pass), ], shape = 16, size = rel(0.8), alpha = 0.7) +
  geom_abline(slope = 1, intercept = 0, linetype = 'dashed') +
  geom_point(data = abundXY[(fltr_pass), ], shape = 16, size = rel(1)) +
  geom_label_repel(data = abundXY[(mark), ], colour = 'black', min.segment.length = 0, segment.size = 0.3, size = rel(2), force = 2, force_pull = 0.01, max.overlaps = 100) +
  scale_x_log10() +
  scale_y_log10() +
  scale_colour_manual(values = c('grey50', '#2244FF')) +
  labs(title = params$comparison) +
  theme(legend.position = 'bottom')

p_XY
```

## Density distributions

The dotted lines represent the abundance thresholds that will be applied in accepting the DE results: mean raw count in at least one condition > `r params$min_count`, and mean TPM in at least one condition > `r params$min_tpm`.

```{r expresion_density, fig.height=10, fig.width=15}
count_thresh <- data.frame(count_type = factor(c('raw', 'tpm'), levels = c('raw', 'tpm', 'normalised', 'vst'), ordered = TRUE), thresh = c(params$min_count, params$min_tpm))

p_dense <- ((ggplot(DT[count_type != 'vst' & mainvar == 'reference', .(sample, abundance, count_type, mainvar)], 
                    aes(x = abundance, colour = sample)) +
              facet_grid(count_type ~ mainvar, scales = 'free') +
              geom_vline(data = count_thresh, aes(xintercept = thresh), linetype = 'dotted') +
              geom_density() +
              scale_x_log10() +
              labs(title = 'Abundance distribution') +
              theme(legend.position = 'left') ) +
              
            (ggplot(DT[count_type != 'vst' & mainvar == 'target', .(sample, abundance, count_type, mainvar)], 
                    aes(x = abundance, colour = sample)) +
              facet_grid(count_type ~ mainvar, scales = 'free') +
              geom_vline(data = count_thresh, aes(xintercept = thresh), linetype = 'dotted') +
              geom_density() +
              scale_x_log10() +
              labs(title = 'Abundance distribution') +
              theme(legend.position = 'right') )) /

            ((ggplot(DT[count_type == 'vst' & mainvar == 'reference', .(sample, abundance, count_type, mainvar)], 
                     aes(x = abundance, colour = sample)) +
                facet_grid(count_type ~ mainvar, scales = 'free', switch = 'x') +
                geom_density() +
                theme(legend.position = 'none') ) |
               
            (ggplot(DT[count_type == 'vst' & mainvar == 'target', .(sample, abundance, count_type, mainvar)], 
                    aes(x = abundance, colour = sample)) +
                facet_grid(count_type ~ mainvar, scales = 'free', switch = 'x') +
                geom_density() +
                theme(legend.position = 'none') )) +

            plot_layout(heights = c(3, 1))

p_dense
```


## Selected gene abundances

### Heatmap

The genes are ordered by decreasing fold-change and the samples are grouped by condition.

```{r heatmap, fig.height=40, fig.width=15}
heatXY <- DT[(mark) & count_type != 'normalised', .(gene_id, gene_name, sample, abundance, condGeneMean, count_type, mainvar, log2FoldChange)]
setorder(heatXY, mainvar, log2FoldChange)
heatXY[, sample := factor(sample, levels = unique(sample), ordered = TRUE)]
heatXY[, gene_name := factor(gene_name, levels = unique(gene_name), ordered = TRUE)]

p_heat <- (ggplot(heatXY[count_type == 'tpm', ], aes(x = sample, y = gene_name, fill = log10(abundance))) +
            facet_wrap(~ count_type, scales = 'free') +
            geom_tile() +
            scale_fill_gradient(low = 'black', high = 'yellow') +
            labs(title = params$comparison) +
            theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) ) +

            (ggplot(heatXY[count_type == 'vst', ], aes(x = sample, y = gene_name, fill = abundance)) +
            facet_wrap(~ count_type, scales = 'free') +
            geom_tile() +
            scale_fill_gradient(low = 'black', high = 'yellow') +
            theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) ) +
    plot_layout(ncol = 1)

p_heat
```

### Detail

The genes are ordered by decreasing fold-change.

The dotted lines represent the abundance criteria: mean raw count in at least one condition > `r params$min_count`, and mean TPM in at least one condition > `r params$min_tpm`.

```{r details, fig.height=20, fig.width=15}
cntthresh <- data.frame(count_type = factor(c('raw', 'tpm'), ordered = TRUE, levels = c('raw', 'tpm', 'normalised', 'vst')), abundance = c(params$min_count, params$min_tpm))

p_box <- ggplot(heatXY[count_type != 'normalised', ], aes(y = gene_name, x = abundance, colour = mainvar)) +
  facet_wrap(~ count_type, nrow = 1, scales = 'free_x') +
  geom_vline(data = cntthresh, aes(xintercept = abundance), linetype = 'dotted') +
  geom_jitter(shape = 16, size = rel(1), height = 0.2) +
  geom_boxplot(fill = 'transparent', outlier.alpha = 0, width = 0.5, linewidth = 0.2) +
  # scale_x_continuous(trans = 'log2') +
  # scale_x_continuous(trans = 'sqrt') +
  scale_x_log10() +
  scale_colour_manual(values = c('blue', 'red')) + 
  labs(title = params$comparison) +
  theme(legend.position = 'bottom', panel.grid.minor.x = element_blank())

p_box
```


# GSEA

The genes are ranked by the shrunken log2 fold-change.

Gene-sets are considered enriched if they meet the criterion: FDR < `r params$max_q`. When multiple gene-set resources are queried, the default multiple-testing correction is inadequate, as it is performed for each resource separately. Therefore a new correction is carried out to encompass the real total number of tests.

Only gene-sets that meet the FDR cutoff are shown in the plots and tables below. Out of those, only the highest enrichment scores are labeled in the plots, for legibility.

```{r gsea_prep}
ranks <- unique(DT[is.finite(shrunkLFC), .(gene_name, shrunkLFC)])
# Some Ensembl IDs map to the same gene symbol. 
# This is an issue for GSEA.
# Keep only one of each duplicate, the one with the largest absolute effect
ranks[, absSLFC := abs(shrunkLFC)]
setorder(ranks, gene_name, -absSLFC)
ranks <- ranks[, head(.SD, 1), by = gene_name]

run_fgsea <- function(gmts, x, tail, q, comparison, title) {
  gsea <- Reduce(rbind, 
                 mclapply(gmts, 
                        function(gmt) {
                          pathways <- gmtPathways(gmt)
                          res <- fgsea(pathways = pathways, stats = x, 
                                       minSize = 15, maxSize = 500, scoreType = tail, nPermSimple = 10000)
                          setorder(res, padj, NES)
                          
                          dir.create(file.path(params$da_path, 'tables', 'gsea', comparison, sub('.gmt', '', basename(gmt))), recursive=TRUE)
                          fwrite(res, file = file.path(params$da_path, 'tables', 'gsea', comparison, sub('.gmt', '', basename(gmt)), paste0(title, '.fgsea_', tail, '_', sub('.gmt', '', basename(gmt)), '.tsv')),
                                 col.names = TRUE, quote = FALSE, sep = '\t')
                          
                          message(basename(gmt), ' : ', nrow(res[padj < q, ]), ' significant pathways, out of ', nrow(res))
                          
                          res[, resource := basename(gmt)]
                          res[, side := tail]
                          res
                        }, mc.cores = threads) )
  
  # Querying multiple pathway resources means that the pval were not cocrected for the actual total number of tests. Correct again.
  if(length(gmts) > 1) {
    message('Applying multiple-testing correction across all the pathway sources combined.')
    gsea[, padj_meta := p.adjust(pval, 'BH')] 
  } else {
    gsea[, padj_meta := padj] # so I don't have to handle number of sets outside this function
  }
    
}

plot_fgsea <- function(res, title, ncol, n, q = params$max_q) {
  # res <- gsea1; ncol <- 1; n <- 20; title <- 'foobar'
  
  res[, absNES := abs(NES)]
  setorder(res, -absNES)
    
  twosides <- any(res$NES < 0)
  
  pl <- lapply( unique(res$resource), function (r) {
    # r <- unique(res$resource)[1]
    subres <- res[resource == r, ]
    
    if (twosides) {
        p <- ggplot(subres, aes(x = NES, y = -log10(padj), label = pathway)) +
            facet_grid(resource ~ side, scales = 'free') +
            # geom_vline(xintercept = 0, linetype = 'dashed') + 
            geom_point(aes(size = size, fill = padj_meta < q), shape=21, colour = 'darkorange2', alpha=0.6) +
            geom_text_repel(data = subres[, head(.SD, floor(n)), by = c('resource', 'side')], 
                            colour = 'blue', segment.color='black', min.segment.length = 0, segment.size = 0.3, size = rel(2.5), force = 20, max.overlaps = 500) +
            scale_fill_manual(values = c('gold', 'darkorange2')) +
            labs(title = title)
    } else {
      p <- ggplot(subres, aes(x = NES, y = -log10(padj), label = pathway)) +
            facet_wrap(~ resource, scales = 'free', ncol = ncol) +
            # geom_vline(xintercept = 0, linetype = 'dashed') + 
            geom_point(aes(size = size, fill = padj_meta < q), shape=21, colour = 'darkorange2', alpha=0.6) +
            geom_text_repel(data = subres[, head(.SD, floor(n)), by = c('resource', 'side')], 
                            colour = 'blue', segment.color='black', min.segment.length = 0, segment.size = 0.3, size = rel(2.5), force = 20, max.overlaps = 500) +
            scale_fill_manual(values = c('gold', 'darkorange2')) +
            labs(title = title)
    }
    
    p
  })

  pl
}


plot_leading_genes <- function(res, DT, genes) {
  genes <- split(genes, '\\s*,\\s*')[[1]]
  
  heatXY <- DT[(gene_name %in% genes) & count_type == 'vst', .(gene_id, gene_name, sample, abundance, condGeneMean, count_type, mainvar, log2FoldChange)]
  setorder(heatXY, mainvar, log2FoldChange)
  heatXY[, sample := factor(sample, levels = unique(sample), ordered = TRUE)]
  heatXY[, gene_name := factor(gene_name, levels = unique(gene_name), ordered = TRUE)]
  
  p_box <- ggplot(heatXY[count_type != 'normalised', ], aes(y = gene_name, x = abundance, colour = mainvar)) +
    facet_wrap(~ count_type, nrow = 1, scales = 'free_x') +
    geom_vline(data = cntthresh, aes(xintercept = abundance), linetype = 'dotted') +
    geom_jitter(shape = 16, size = rel(1), height = 0.2) +
    geom_boxplot(fill = 'transparent', outlier.alpha = 0, width = 0.5, linewidth = 0.2) +
    # scale_x_continuous(trans = 'log2') +
    # scale_x_continuous(trans = 'sqrt') +
    scale_x_log10() +
    scale_colour_manual(values = c('blue', 'red')) + 
    labs(title = params$comparison) +
    theme(legend.position = 'bottom', panel.grid.minor.x = element_blank())
  
  p_box
}
```

## Direction-agnostic

The idea is that the same gene-set could have genes that are up-regulated and other genes that are down-regulated. So we are only interested in the fact that they are strongly effected and we are looking only for enrichment of gene-sets containing effected genes.

```{r twotail}
# Not using the two-tail test, because I am unsure how it will behave if there is a strong asymmetry in the fold-changes.

setorder(ranks, absSLFC)
rn2 <- ranks$gene_name
ranks2 <- ranks$absSLFC
names(ranks2) <- rn2

gsea2 <- run_fgsea(params$genesets, ranks2, 'pos', params$max_q, params$comparison, paste0(params$comparison, '.absLFC'))
gsea2 <- gsea2[padj < params$max_q, ]
message(nrow(gsea2), ' candidate gene-sets for differentially regulated genes.')
```

### Table 

Table of all qualifying gene-sets, across all the gene-set libraries used. Only significant gene-sets are listed.

`padj` has been adjusted only within the context of the gene-set category. `padj_meta` is the Benjamini-Hochberg adjusted p-value for all the gene-sets tested across all the included categories.

```{r twotail_tb}
datatable(gsea2[, .(side, pathway, padj, padj_meta, NES, size, leadingEdge)], )
```

### NES & Significance

Only significant gene-sets are shown.

The Y axis displays the within-category adjusted p-value. Yellow points indicate gene-sets that no longer meet the significance level after p-value correction across categories, whereas brown points indicate gene-sets that remain significant.

```{r twotail_volcano, fig.height=15, fig.width=18}
if (nrow(gsea2) > 0) {
  p_rich2 <- plot_fgsea(gsea2, paste0(params$comparison, '.absLFC'), 1, 40)
  
  pdf(file = file.path(params$da_path, 'plots', 'gsea', params$comparison, paste0(params$comparison, '.absLFC.fgsea.pdf')), width=20, height=40)
  print(p_rich2)
  dev.off()
  
  print( p_rich2 )
}
```

## Direction-specific

Looking for gene-sets enriched in either the up-regulated (pos) or down-regulated (neg) genes.

```{r onetail}
setorder(ranks, shrunkLFC)
rn1 <- ranks$gene_name
ranks1 <- ranks$shrunkLFC
names(ranks1) <- rn1

gsea1 <- rbind(run_fgsea(params$genesets, ranks1, 'pos', params$max_q, params$comparison, params$comparison),
               run_fgsea(params$genesets, ranks1, 'neg', params$max_q, params$comparison, params$comparison) )
# # Re-do the multiple-testing correction to encompass the total number of tests from both sides.
# gsea1[, padj_meta := p.adjust(pval, method = 'BH')]
gsea1 <- gsea1[padj < params$max_q, ]

message(nrow(gsea1[side == 'pos', ]), ' candidate gene-sets for the up-regulated genes.')
message(nrow(gsea1[side == 'neg', ]), ' candidate gene-sets for the down-regulated genes.')
```

### Table

Table of all qualifying gene-sets, across all the gene-set libraries used. Only significant gene-sets are listed.

`padj` has been adjusted only within the context of the gene-set category. `padj_meta` is the Benjamini-Hochberg adjusted p-value for all the gene-sets tested across all the included categories.

```{r onetail_tb}
datatable(gsea1[, .(side, pathway, padj, padj_meta, NES, size, leadingEdge)])
```

### NES & Significance

Only significant gene-sets are shown.

The Y axis displays the within-category adjusted p-value. Yellow points indicate gene-sets that no longer meet the significance level after p-value correction across categories, whereas brown points indicate gene-sets that remain significant.

```{r onetail_volcano, fig.height=15, fig.width=18}
if (nrow(gsea1) > 0 ) {
  p_rich1 <- plot_fgsea(gsea1, params$comparison, 1, 20)
  
  pdf(file = file.path(params$da_path, 'plots', 'gsea', params$comparison, paste0(params$comparison, '.fgsea.pdf')), width=20, height=40)
  print(p_rich1)
  dev.off()
  
  print( p_rich1 )
}
```



# Session

```{r session}
sessionInfo()
```

