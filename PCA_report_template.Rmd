---
title: "PCA & Correlations"
author: "Kimon Froussios"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
params:
  cts: "./null_xref.tsv"               # a file MUST be specified
  covars: "./null_covars.txt"          # a file MUST be specified
  RDSdir: "."                          # a file MUST be specified
  pdf: "./null_pca.pdf"                # a file MUST be specified
  nidcols: 1                           # how many columns contain alternative IDs, including the col with the row IDs
  idcol: 1                               # column that has the row IDs
  ntop: 10                               # maximum number of hits to list
  minMean: 10                            # Filter out poorly covered genes
  minSingle: 100                         # Bypass of the above, for genes expressed only in one or few samples
editor_options:
  chunk_output_type: console
---

\VignetteEngine{knitr::knitr}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

```{r message=FALSE, warning=FALSE}
library(data.table)
library(ggplot2)
library(htmltools)
library(patchwork)
library(matrixStats)
library(ggExtra)
library(ggforce)
library(ggdendro)
library(ggrepel)

options(scipen=2)

theme_set(theme_bw())
```

```{r functions}
# Correlations
my_pairwise_internal_corels <- function(mat, samples, method = "pearson", rds=NULL, txs=3, minMean=0, minSingle=0, sizefactor=1) {
  # mat <- counts; samples <- covars$Samp
  
  if (method == "pearson") libsizes <- colSums(mat)
  # Filter
  if (minMean != 0 | minSingle != 0) {
    mat <- mat[rowSums(mat >= minSingle) >= 1 | rowMeans(mat) >= minMean, ]
  } else {
    mat <- mat[rowSums(mat) > 0, ]
  }
  # Scale
  if (method == "pearson") {
    mat <- sweep(mat, 2, libsizes, `/`) * sizefactor
  }

  # Correlations
  cormat <- cor(mat, method=method)
  
  # Cluster
  hcfit <- hclust(dist(scale(cormat, center=TRUE)))
  rn <- rownames(cormat)
  
  # Make dendrogram. https://stackoverflow.com/questions/42047896/joining-a-dendrogram-and-a-heatmap
  dend <- as.dendrogram(hcfit)
  dend_data <- dendro_data(dend)
  # Setup the data, so that the axes are exchanged, instead of using coord_flip()
  segment_data <- with(
      segment(dend_data), 
      data.frame(x = y, y = x, xend = yend, yend = xend))
  # Use the dendrogram label data to position the sample labels
  sample_pos_table <- with(
      dend_data$labels, 
      data.frame(y_center = x, Sample = as.character(label), height = 1))
  # Limits for the vertical axes
  sample_axis_limits <- with(
      sample_pos_table, 
      c(min(y_center - 0.5 * height), max(y_center + 0.5 * height))
  ) + 0.1 * c(-1, 1) # extra spacing: 0.1
  # Dendrogram plot
  pd <- ggplot(segment_data) + 
    geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) + 
    scale_x_reverse(expand = c(0, 0.5),
                    position = "top") + 
    scale_y_continuous(position = "right",
                       breaks = sample_pos_table$y_center, 
                       labels = sample_pos_table$Sample, 
                       limits = sample_axis_limits, 
                       expand = c(0, 0)) + 
    labs(x = NULL, y = NULL) +
    theme_minimal() + 
    theme(panel.grid = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank())

  
  # Create duplicates for different plot styles
  cormat <- cormat[samples, samples]                    # Supplied order
  cormat2 <- cormat                                     # Duplicate in which to delete below the diagonal.
  cormat3 <- cormat[rn[hcfit$order], rn[hcfit$order]]   # Duplicate in clustered order.
  cormat4 <- cormat3                                    # Duplicate in clustered order in which to delete below the diagonal.
  # Delete below diagonal half for the numeric labels.
  for (r in 1:nrow(cormat2)) {
    for (c in 1:ncol(cormat2)) {
      if (c <= r) {
        cormat2[r, c] <- NA_real_
      }
    }
  }
  for (r in 1:nrow(cormat4)) {
    for (c in 1:ncol(cormat4)) {
      if (c <= r) {
        cormat4[r, c] <- NA_real_
      }
    }
  }
  
  # Restructure for plotting.
  rn <- rownames(cormat)
  cormat <- as.data.table(cormat)
  cormat[, observation1 := factor(rn, ordered=TRUE, levels=rn)]
  cormat <- melt(cormat, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat[, observation2 := factor(observation2, ordered=TRUE, levels=rn)]
  # cormat <- merge(cormat, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  rn2 <- rownames(cormat2)
  cormat2 <- as.data.table(cormat2)
  cormat2[, observation1 := factor(rn2, ordered=TRUE, levels=rn2)]
  cormat2 <- melt(cormat2, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat2[, observation2 := factor(observation2, ordered=TRUE, levels=rn2)]
  cormat2 <- cormat2[!is.na(Correlation)]
  # cormat2 <- merge(cormat2, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  rn3 <- rownames(cormat3)
  cormat3 <- as.data.table(cormat3)
  cormat3[, observation1 := factor(rn3, ordered=TRUE, levels=rn3)]
  cormat3 <- melt(cormat3, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat3[, observation2 := factor(observation2, ordered=TRUE, levels=rn3)]
  # cormat3 <- merge(cormat3, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  rn4 <- rownames(cormat4)
  cormat4 <- as.data.table(cormat4)
  cormat4[, observation1 := factor(rn3, ordered=TRUE, levels=rn4)]
  cormat4 <- melt(cormat4, id.vars = "observation1", value.name = "Correlation", variable.name = "observation2")
  cormat4[, observation2 := factor(observation2, ordered=TRUE, levels=rn4)]
  cormat4 <- cormat4[!is.na(Correlation)]
  # cormat4 <- merge(cormat4, sample_pos_table, by.x="observation2", by.y="Sample", all.x=TRUE)
  
  # Text colour switch for the dynamic range
  m <- min(cormat4$Correlation, na.rm=TRUE)
  M <- max(cormat4$Correlation, na.rm=TRUE)
  colourswitch <- c( m + 0.49 * (M-m),  m + 0.51 * (M-m) )
  
  
  # # Square. Custom order. No values. Full range.
  # p1 <- ggplot(cormat, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
  #   scale_x_discrete(position = "top") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Square. Custom order. No values. Dynamic range.
  # p1a <- ggplot(cormat, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
  #   scale_x_discrete(position = "top") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Triangle. Custom order. With values. Full range.
  # p2 <- ggplot(cormat2, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
  #   scale_x_discrete(position = "top") +
  #   scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
  #   scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Triangle. Custom order. With values. Dynamic range.
  # p2a <- ggplot(cormat2, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
  #   scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
  #   scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
  #   scale_x_discrete(position = "top") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  
  # Square. Custom order. With values. Full range.
  p12 <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat2, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_x_discrete(position = "top") +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Custom order. With values. Dyhamic range.
  p12a <- ggplot(cormat, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat2, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  
  # # Square. Clustered order. No values. Full range.
  # p3 <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
  #   scale_x_discrete(position = "top") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Square. Clustered order. No values. Dyhamic range.
  # p3a <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
  #   scale_x_discrete(position = "top") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Triangle. Clustered order. with values. Full range.
  # p4 <- ggplot(cormat4, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
  #   scale_x_discrete(position = "top") +
  #   scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
  #   scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  # 
  # # Triangle. Clustered order. with values. Dyhamic range.
  # p4a <- ggplot(cormat4, aes(x=observation1, y=observation2)) +
  #   geom_tile(aes(fill=Correlation)) +
  #   geom_text(aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
  #   scale_x_discrete(position = "top") +
  #   scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "transparent" ) +
  #   scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
  #   labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
  #   theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
  #         panel.grid = element_blank() )
  
  # Square. Clustered order. With values. Full range.
  p34 <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat4, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=Correlation >= -0.60 & Correlation <= 0.60 ), size=rel(txs)) +
    scale_fill_gradientn(limits=c(-1, 1), colors=c("lightskyblue", "dodgerblue3", "darkblue", "black", "darkred", "red", "gold"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c('FALSE'="black", 'TRUE'="white"), na.value="forestgreen", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  # Square. Clustered order. With values. Dyhamic range.
  p34a <- ggplot(cormat3, aes(x=observation1, y=observation2)) +
    geom_tile(aes(fill=Correlation)) +
    geom_text(data=cormat4, aes(label=sub('0.', '.', as.character(round(Correlation, 2))), colour=(Correlation <= colourswitch[2]) ), size=rel(txs)) +
    scale_fill_gradientn(colors=c("black", "red", "gold", "white"), na.value = "forestgreen" ) +
    scale_colour_manual(values=c("black", "white"), na.value="transparent", guide="none") +
    scale_x_discrete(position = "top") +
    labs(x='', y='', title=paste(paste(toupper(substr(method, 1, 1)), tolower(substr(method, 2, nchar(method))), "'s", sep=""), "correlation - Clustered")) +
    theme(axis.text.x=element_text(angle=90, hjust=0, vjust=0.5),
          panel.grid = element_blank() )
  
  out <- list(corr=dcast(cormat2, observation1 ~ observation2, value.var = "Correlation"),
              # sfrnc=p1, tfrnc=p2, sdrnc=p1a, tdrnc=p2a,
              frnc=p12, drnc=p12a,
              # sfrc=pd + p3, tfrc=p4, sdrc=pd + p3a, tdrc=p4a,
              frc=pd + p34 + plot_layout(ncol=2, widths=c(1,4)), 
              drc=pd + p34a + plot_layout(ncol=2, widths=c(1,4)))
  
  if (!is.null(rds)) {
    saveRDS(out, file = rds)
  }
  
  return(out)
}

# PCA
# (scaling and centering of genes to one another, NOT samples to one another)
pca_plotter <- function(pc, loads, highloads, ig, pcaimp, pcx, pcy){  ## helper function
  # pcx <- 1; pcy <- 2
  mycolours <- c(
    "#dd2200", "#0066ff", "#8800ff", "#ff8833", "#229900", 
    "#880000", "#0000ff", "#5500aa", "#bb6600", "#224400",
    "#eeaabb", "#00ccff", "#ff77ff", "#ffcc00", "#22cc00",
    "#8899aa",
    "#ff00dd", "#0099ff", "#8866ff", "#22ff00", "#886600", 
    "#889900", "#88ccff", "#eeeeaa", "#0066aa", "#0099aa"
  )
  pcxs <- paste0("PC", pcx)
  pcys <- paste0("PC", pcy)
  subload <- loads[rowID %in% unique(c(head(highloads[[pcx]], 5), head(highloads[[pcy]], 5))), c("rowID", pcxs, pcys), with=FALSE]
  
  pc12 <- wrap_plots(lapply(ig, function(varname) {
    return(
      ggplot(pc, aes_string(x=pcxs, y=pcys, label="Sample", fill=varname, colour=varname)) +
        geom_vline(xintercept=0, linetype='dashed', colour='grey70') +
        geom_hline(yintercept=0, linetype='dashed', colour='grey70') +
        geom_mark_hull(alpha=0.1, colour='transparent') +
        geom_point() +
        # geom_text_repel(data=subload, inherit.aes=FALSE, aes_string(label="rowID", x=pcxs, y=pcys), size=2) +
        coord_fixed() +
        scale_colour_manual(values=mycolours) +
        scale_fill_manual(values=mycolours) +
        labs(x=paste0(pcxs, " (", round(pcaimp[PC==pcx, Explained], 1), "%)"), 
             y=paste0(pcys, " (", round(pcaimp[PC==pcy, Explained], 1), "%)")) +
        theme(panel.grid=element_blank())
    )}), ncol = 2)
  
  pc12v <- wrap_plots(lapply(ig, function(varname) {
    return(
      ggplot(pc, aes_string(x=pcxs, y=pcys, label="Sample", fill=varname, colour=varname)) +
        geom_vline(xintercept=0, linetype='dashed', colour='grey70') +
        geom_hline(yintercept=0, linetype='dashed', colour='grey70') +
        # geom_mark_hull(alpha=0.1, colour='transparent') +
        geom_segment(data=subload, inherit.aes=FALSE, colour='black', arrow=arrow(length=unit(0.1, 'cm')), alpha=0.2,
                     x=0, y=0, aes_string(xend=pcxs, yend=pcys)) +
        geom_point() +
        geom_text_repel(data=subload, inherit.aes=FALSE, aes_string(label="rowID", x=pcxs, y=pcys), size=2) +
        coord_fixed() +
        scale_colour_manual(values=mycolours) +
        scale_fill_manual(values=mycolours) +
        labs(x=paste0(pcxs, " (", round(pcaimp[PC==pcx, Explained], 1), "%)"), 
             y=paste0(pcys, " (", round(pcaimp[PC==pcy, Explained], 1), "%)")) +
        theme(panel.grid=element_blank())
    )}), ncol = 2)
  
  return(list(pc12, pc12v))
}

do_pca <- function(countsmat, covars, scale = TRUE, center = TRUE, rds=NULL, topgenes=NULL, minMean=0, minSingle=0, ntop=10) {
  # countsmat <- counts; covars <- covars
  
  nvars <- nrow(countsmat)
  countsmat <- countsmat[rowSums(countsmat) > 0, ]
  
  # Mean and Standard Deviation, standardized counts, mean and stdev of standardized counts.
  genevar <- data.table(name = rownames(countsmat),
                        Mean = rowMeans(countsmat),
                        StDev = rowSds(countsmat),
                        singles = rowSums(countsmat > minSingle))
  normcounts <- (countsmat - genevar$Mean) / genevar$StDev
  genevar [, zMean := rowMeans(normcounts)]
  # genevar [, zStDev := rowSds(normcounts)]    # always 1 by definition
  
  # Select features
  if (is.null(topgenes)) {
    message(paste("Using variable features that exceed either", minMean, "mean count or", minSingle, "count in any single sample."))
    topgenes = genevar[StDev > 0 & (Mean >= minMean | singles >= 1), name]  # all the variable genes, above min count level
  } else {
    message("Using variable features among the manually provided list.")
    topgenes = genevar[name %in% topgenes & StDev > 0, name] # manually provided features, as long as they are variable
  }
  subcmat <- countsmat[topgenes, ]
  
  # Rotate counts so genes are variables and samples are observations
  subcmat <- t(subcmat)
  message(paste("Number of variable features available:", nrow(genevar[StDev>0,])))
  message(paste("Number of variable features used:", length(topgenes)))
  
  # PCA
  pca <- prcomp(subcmat, center = center, scale = scale)
    
  srn <- sqrt(nrow(pca$x) - 1)
  pc <- sweep(pca$x, 2, 1 / (pca$sdev * srn), FUN = '*')   
  dirs <- as.data.table(pca$rotation)
  
  pc <- cbind(pc, data.frame(Sample = rownames(pc)))
  pc <- as.data.frame(merge(pc, covars, by="Sample", all = TRUE))
  npc <- sum(pca$sdev > 1)
  
  # Screeplot.
  
  pcaimp <- data.table(PC = 1:length(colnames(pca$x)),
                       Explained = summary(pca)$importance['Proportion of Variance', ] * 100,
                       Cumulative = summary(pca)$importance['Cumulative Proportion', ] * 100)
  pcaimp <- pcaimp[1:npc, ]
  topnpc <- nrow(pcaimp[Explained >= 1])
  
  pimp <- ggplot(pcaimp) +
    geom_line(aes(x=PC, y=Cumulative), colour='dodgerblue') +
    geom_bar(aes(x=PC, y=Explained, fill=Explained >= 1),
             stat='identity', colour='transparent', alpha=0.3) +
    geom_text(aes(x=PC, y=0, label=paste0(round(Explained, 1),"%")), 
              angle=90, hjust=0, vjust=0, size=rel(3)) +
    geom_text(data=pcaimp[2:npc,],
              aes(x=PC, y=0.95*Cumulative, label=paste0(round(Cumulative, 1),"%")), 
              angle=90, vjust=0, hjust=1, size=rel(3)) +
    scale_fill_manual(values=c("grey25", "grey75"), guide="none") +
    scale_x_continuous(breaks=seq.int(1, npc, 1)) +
    labs(title = "Scree plot", subtitle=paste0(nvars, " features, ", npc, " PCs"), 
         x = "Principal Component", y='% Variance') +
    theme(panel.grid=element_blank())
    
  
  # Top influencers. 
  
  infl <- as.data.table(pca$rotation)
  highinfl <- lapply(infl, function(x){ order(abs(x), decreasing=TRUE) })
  infl[, rowID := rownames(pca$rotation)]
  highinfl <- lapply(highinfl, function(x){ head(infl$rowID[x], ntop) })
  highinfl <- highinfl[1:topnpc]
  setkey(infl, rowID)
  
  # Influence plots
  # lapply(1:npc, function(i) {
  #   ggplot(infl[highinfl[[i]], 
  #             c('rowID', names(loads)[i]), with=FALSE], 
  #        aes_string(x="rowID", xend="rowID", y=0, yend=names(loads)[i])) +
  #   geom_segment() +
  #   geom_point(aes_string(y=names(loads)[i])) +
  #   coord_flip() +
  #   labs(y=NULL, x=NULL)
  # })
  
  # Coefficient names.

  ig <- names(covars)
  ig <- ig[! ig %in% c('sample', 'Sample', 'name', 'Name', 'sizeFactor')]

  # Means and Variances of the selected genes
  genevar[, selected := name %in% colnames(subcmat)]
  pvar1 <- ggMarginal(
    ggplot(genevar, aes(x=Mean, y=StDev, label=name, colour=selected)) +
      geom_point(shape=16, size=0.8, alpha=0.3) +
      scale_x_log10() +
      scale_y_log10() +
      scale_colour_manual(values=c("black", "red")) +
      labs(x="Mean", y="Standard Deviation", title=paste("Features:", nrow(genevar), "total"), 
           subtitle=paste(nrow(genevar[StDev>0,]), "variable,", length(topgenes), "used")),
    type = "histogram")

  # Plot higher PCs in 2D pairs. Highlight one variable at a time.
  L <- lapply(seq(1, topnpc, 2), function(pcx){
    pcy <- pcx + 1
    if (pcy > npc) pcy <- 1
    pca_plotter(pc, infl, highinfl, ig, pcaimp, pcx, pcy)
  } )
  
  L1 <- lapply(L, function(x) { x[[1]] })
  L2 <- lapply(L, function(x) { x[[2]] })
  
  out <- list(pca=pca,
              nvars=nvars,
              nPC=npc,
              pimp=pimp, pvar1=pvar1,
              highloads=highinfl,
              pc2d=L1, pcv2d=L2
              )
  
  if (!is.null(rds)) {
    saveRDS(out, file = rds)
  }
  
  return(out)
}
```


# Input

```{r input}
covars <- fread(params$covars, colClasses = 'c')

counts <- fread(params$cts)
counts <- counts[, c(names(counts)[1:params$nidcols], covars$Sample), with=FALSE]    # Only samples specified in covars.
n <- counts[, params$idcol, with=FALSE]
counts <- as.matrix(counts[, (params$nidcols+1):length(counts)])
rownames(counts) <- n[[1]]
counts[is.na(counts)] <- 0
```

# Correlations

Similarly as for the PCA in the next section of the report, genes with mean raw count across all samples below `r params$minMean` are excluded, unless any of the samples has raw count of at least `r params$minSingle`. 

The *Pearson* correlation coefficient between samples X and Y measures how much their observations can be represented as `Y = A * X`. Perfect PCC is a straight line in a 2D plot of corresponding X,Y value pairs. The *Spearman* correlation coefficient does the same for the rank of the observations instead of their values. Perfect SCC is any monotonic line beteen X and Y values (straight, curved, or zigzag).
Between true replicate samples, linearity might be expected and PCC should be high, but gene expression is noisy so SCC is often a little better. With samples from different conditions, the coefficients may disagree as a result of how observation density is distributed along the axes. SCC will amplify differences in areas dense with observations while down-playing differences in sparse areas.

The *first plot* in each subsection below is scaled to the full range of correlation values `(-1, 1)`, and gives an objective overview of how good correlations are (or aren't). The samples are ordered on the axes as per the order provided.
The *second plot* is scaled to the range of values actually obtained for this dataset and the samples are ordered by hierarchical clustering. This amplifies contrast and highlights structure. Samples belonging to the same condition are expected to cluster next to each other.

## Pearson

To remove any influence of library size that may affect Pearson correlation, samples are first scaled to RPM.

```{r pearson1, fig.height=12, fig.width=12}
# scaling is built into the function
corels1 <- my_pairwise_internal_corels(counts, covars$Sample, method="pearson",
                                      minMean = params$minMean, minSingle = params$minSingle,
                                      sizefactor=1000000,
                                      rds = file.path(params$RDSdir,
                                                      sub(".txt|.tsv", "_corrP.RDS", basename(params$cts))))
print(corels1[["frnc"]])
```

```{r pearson2, fig.height=12, fig.width=16}
print(corels1[["drc"]])
```

### Comments

TODO

## Spearman

```{r spearman1, fig.height=12, fig.width=12}
corels2 <- my_pairwise_internal_corels(counts, covars$Sample, method="spearman",
                                      minMean = params$minMean, minSingle = params$minSingle,
                                      rds = file.path(params$RDSdir,
                                                      sub(".txt|.tsv", "_corrS.RDS", basename(params$cts))))
print(corels2[["frnc"]])
```

```{r spearman2, fig.height=12, fig.width=16}
print(corels2[["drc"]])
```

### Comments

TODO

# PCA

For this report, the expression of the genes have been standardized. This compensates for large differences in magnitude range and gives every gene equal weight. Otherwise the variance from high expression genes would dominate in the determination of principal components. Genes with exactly `0` variability have to be excluded for PCA, they are typically genes that are not detected in any of the samples.

Giving equal weight to all genes, can introduce noise from low expression genes. To reduce this, genes with mean raw count across all samples below `r params$minMean` are excluded, unless any of the samples has raw count of at least `r params$minSingle`. This exception should allow for fringe cases where most samples do not express a gene, but a small subset do express it, as might happen in an experimental setup with many samples and many conditions.

```{r pca}
all_pca <- do_pca(counts, covars, 
                  minMean = params$minMean, minSingle = params$minSingle, ntop = params$ntop,
                  rds = file.path(params$RDSdir,
                                  sub(".txt|.tsv", "_pca.RDS", basename(params$cts))))
```

## Plots

2D plots of the principal components in pairs.

### Selected features

This shows the mean value and standard deviation for the variable features that were selected for the correlation and PCA, agaisnt the total of variable features. Non-variable features are not shown, due to log-scaled axes.

```{r varmean}
# Selected features
print( all_pca$pvar1 )
```

### Variance explained by PCs

There are different ways to decide which components to consider important. One is based on the idea of diminishing returns and selects components before the "elbow" in the cumulative variance. The second considers all components that explain at least 1%. The third simply aims for a target cumulative variance explained, like 80%.

```{r scree}
# Scree
print(all_pca$pimp)
```

#### Comments

TODO

### Known variables

Highlighting the defined experimental variables against the principal components helps make sense of what the components are.

```{r pcs, fig.width=8, fig.height=12}
print( all_pca$pc2d )
```

#### Comments

TODO

## Associated features

Only the top `r params$ntop` genes are listed here, in order of decreasing association.

If a PC aligns well with an experimental variable of interest, the associated genes for that PC could merit follow-up.

```{r highload}
for (pc in names(all_pca$highloads)) {
  cat("\n")
  print( pc )
  print( head(all_pca$highloads[[pc]], params$ntop) )
}
```


<!-- ## Filtered correlation -->

<!-- Calculated using only the selected variable features. -->

<!-- ```{r fig.width=16, fig.height=16} -->
<!-- print( all_pca[["pcor1"]] ) -->
<!-- print( all_pca[["pcor2"]] ) -->
<!-- ``` -->


# Write plots to PDF

```{r pdf}
## Plots to PDF ##


pdf(file.path(params$RDSdir,
              sub(".txt|.tsv", "_pca.pdf", basename(params$cts))),
    width=max(12, ceiling(nrow(covars) / 3)), height=max(12, ceiling(nrow(covars) / 3))) # Scale up when many samples, but don't scale down when few.

# Correlation plots
print(corels1[['frnc']])
print(corels1[['drc']])
print(corels2[['frnc']])
print(corels2[['drc']])

# PCA plots
print(all_pca$pimp)
print(all_pca$pcv2d)
# print(all_pca[["pcor1"]])
# print(all_pca[["pcor2"]])

print( ggplot() + geom_point() + theme_void()) # The ggmargin plot in pvar1 doesn't create its own page
print( all_pca$pvar1 )


dev.off()
```

# Session Info

```{r}
sessionInfo()
```
