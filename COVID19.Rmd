---
title: "COVID19"
author: "Kimon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    code_folding: hide
    toc: yes
    toc_float: yes
    toc_depth: 4
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE)
```

```{r message=FALSE}
library(httr)
library(lubridate)
library(ggplot2)
library(ggrepel)
library(patchwork)
library(data.table)
library(maps)

options(scipen=2)
```

Source: https://opendata.ecdc.europa.eu/covid19/


# Load current data

```{r}
# Load data
###########

## Download latest data
# GET("https://opendata.ecdc.europa.eu/covid19/agecasesnational/csv", authenticate(":", ":", type="ntlm"), write_disk('D:/Documents/covid/agecasesnational.csv', overwrite = TRUE))
# GET("https://opendata.ecdc.europa.eu/covid19/agecasesubnational/csv", authenticate(":", ":", type="ntlm"), write_disk('D:/Documents/covid/agecasesubnational.csv', overwrite = TRUE))
# GET("https://opendata.ecdc.europa.eu/covid19/casedistribution/csv", authenticate(":", ":", type="ntlm"), write_disk('D:/Documents/covid/casedistribution.csv', overwrite = TRUE))
# GET("https://opendata.ecdc.europa.eu/covid19/hospitalicuadmissionrates/csv", authenticate(":", ":", type="ntlm"), write_disk('D:/Documents/covid/hospitalicuadmissionrates.csv', overwrite = TRUE))
# GET("https://opendata.ecdc.europa.eu/covid19/movementindicators/csv", authenticate(":", ":", type="ntlm"), write_disk('D:/Documents/covid/movementindicators.csv', overwrite = TRUE))
# GET("https://opendata.ecdc.europa.eu/covid19/nationalcasedeath/csv", authenticate(":", ":", type="ntlm"), write_disk('D:/Documents/covid/nationalcasedeath.csv', overwrite = TRUE))
# GET("https://opendata.ecdc.europa.eu/covid19/subnationalcasedaily/csv", authenticate(":", ":", type="ntlm"), write_disk('D:/Documents/covid/subnationalcasedaily.csv', overwrite = TRUE))
# GET("https://opendata.ecdc.europa.eu/covid19/subnationalcaseweekly/csv", authenticate(":", ":", type="ntlm"), write_disk('D:/Documents/covid/subnationalcaseweekly.csv', overwrite = TRUE))
# GET("https://opendata.ecdc.europa.eu/covid19/testing/csv", authenticate(":", ":", type="ntlm"), write_disk('D:/Documents/covid/testing.csv', overwrite = TRUE))

# Import data.
# Don't need the cruiseship.
agecasenat <- fread('D:/Documents/covid/agecasesnational.csv')[country != 'Cases_on_an_international_conveyance_Japan', ]
agecasesubnat <- fread('D:/Documents/covid/agecasesubnational.csv') # [country != 'Cases_on_an_international_conveyance_Japan',] # Still blank
casedist <- fread('D:/Documents/covid/casedistribution.csv')[countriesAndTerritories != 'Cases_on_an_international_conveyance_Japan', ]
hosprate <- fread('D:/Documents/covid/hospitalicuadmissionrates.csv')[country != 'Cases_on_an_international_conveyance_Japan', ]
movement <- fread('D:/Documents/covid/movementindicators.csv')[country != 'Cases_on_an_international_conveyance_Japan', ]
natcasedeath <- fread('D:/Documents/covid/nationalcasedeath.csv')[country != 'Cases_on_an_international_conveyance_Japan', ]
subnatcaseday <- fread('D:/Documents/covid/subnationalcasedaily.csv')[country != 'Cases_on_an_international_conveyance_Japan', ]
subnatcaseweek <- fread('D:/Documents/covid/subnationalcaseweekly.csv')[country != 'Cases_on_an_international_conveyance_Japan', ]
testing <- fread('D:/Documents/covid/testing.csv')[country != 'Cases_on_an_international_conveyance_Japan', ]

# Verify that the data format wasn't changed again
stopifnot(names(agecasenat) == c('country', 'country_code', 'year_week', 'age_group', 'new_cases', 'population', 'rate_14_day_per_100k', 'source'))
stopifnot(names(agecasesubnat) == c('Test'))
stopifnot(names(casedist) == c('dateRep', 'year_week', 'cases_weekly', 'deaths_weekly', 'countriesAndTerritories', 'geoId', 'countryterritoryCode', 'popData2019', 'continentExp', 'notification_rate_per_100000_population_14-days'))
stopifnot(names(hosprate) == c('country', 'indicator', 'date', 'year_week', 'value', 'source', 'url'))
stopifnot(names(movement) == c('col0', 'country', 'country_code', 'geo_id_final', 'region', 'subnational_cases_7', 'subnational_cases_14', 'subnational_population', 'subnational_rate_14', 'national_cases_7', 'national_population', 'national_testing_rate', 'national_positivity_rate', 'subnational_testing_data', 'positivity_rate_combined', 'testing_rate_combined', 'colour', 'week'))
stopifnot(names(natcasedeath) == c('country', 'country_code', 'continent', 'population', 'indicator', 'weekly_count', 'year_week', 'rate_14_day', 'cumulative_count', 'source'))
stopifnot(names(subnatcaseday) == c('country', 'region_name', 'nuts_code', 'date', 'rate_14_day_per_100k', 'source'))
stopifnot(names(subnatcaseweek) == c('country', 'region_name', 'nuts_code', 'year_week', 'rate_14_day_per_100k', 'source'))
stopifnot(names(testing) == c('country', 'country_code', 'year_week', 'level', 'region', 'region_name', 'new_cases', 'tests_done', 'population', 'testing_rate', 'positivity_rate', 'testing_data_source'))


# Countries to highlight
########################

homecountry = 'Austria'
# Selected countries
family_countries <- c('Austria', 'Italy', 'Greece', 'Luxembourg', 'Germany')
neighbour_countries <- c('Switzerland', 'Slovakia', 'Slovenia', 'Czechia', 'Hungary')
other_countries <- c('United_Kingdom', 'Spain', 'France', 'Belgium', 'United_States_of_America', 'Sweden', 'South_Korea')


# Make dates workable and uniform
#################################

# str(agecasenat)
##str(agecasesubnat)
# str(casedist)
casedist[, dateRep := dmy(dateRep)]
# str(hosprate)
hosprate[, date := as.Date(date)]
hosprate[, year_week := sub('W', '', year_week)]
# str(movement)
# str(natcasedeath)
# str(subnatcaseday)
subnatcaseday[, date := as.Date(date)]
# str(subnatcaseweek)
subnatcaseweek[, year_week := sub('W', '', year_week)]
# str(testing)
testing[, year_week := sub('W', '', year_week)]


# Map outlines
##############

world_map <- as.data.table(map_data('world'))

## Code template
# ggplot(world_map, aes(x=long, y=lat, group=group)) +
#   geom_polygon(fill='white', colour='black', size=0.01) +
#   coord_cartesian(ylim=c(-60, 80), xlim=c(-180,180)) + # Crop giant Antarctica and empty Arctic
#   theme(panel.background=element_rect(fill=seablue),
#         panel.grid=element_line(colour='white', size=0.1))


# Sanitize country names

# Map data names allow spaces, ECDC uses underscores.
# Spaces are nice, but ECDC tables out-number the coordinates table, so it makes sense to keep the ECDC convention.
# Also, ECDC groups some of these territories together, whereas the map doesn't (except for the Virgin Islands, where it is the other way around)/
world_map[, region := gsub(' ', '_', region,)]

# More mismatched spellings.
world_map[region=='Antigua', region := 'Antigua_and_Barbuda']
world_map[region=='Bonaire', region := 'Bonaire, Saint Eustatius and Saba']
world_map[region=='Sint_Eustatius', region := 'Bonaire, Saint Eustatius and Saba']
world_map[region=='Saba', region := 'Bonaire, Saint Eustatius and Saba']
## world_map[region=='Virgin_Islands', region := 'British_Virgin_Islands']       # I could try to sum the ECDC data, but more trouble than it's worth. 
## world_map[region=='Virgin_Islands', region := 'United_States_Virgin_Islands'] # Fixing the report structure is the priority.
world_map[region=='Brunei', region := 'Brunei_Darussalam']
world_map[region=='Republic_of_Congo', region := 'Congo']
world_map[region=='Ivory_Coast', region := 'Cote_dIvoire']
world_map[region=='Curacao', region := 'CuraÃ§ao']
world_map[region=='Czech_Republic', region := 'Czechia']
world_map[region=='Falkland_Islands', region := 'Falkland_Islands_(Malvinas)']
world_map[region=='Guinea-Bissau', region := 'Guinea_Bissau']
world_map[region=='Vatican', region := 'Holy_See']
world_map[region=='Micronesia', region := 'Micronesia_(Federated_States_of)']
world_map[region=='Nevis', region := 'Saint_Kitts_and_Nevis']
world_map[region=='Saint_Kitts', region := 'Saint_Kitts_and_Nevis']
world_map[region=='Grenadines', region := 'Saint_Vincent_and_the_Grenadines']
world_map[region=='Saint_Vincent', region := 'Saint_Vincent_and_the_Grenadines']
world_map[region=='Macedonia', region := 'North_Macedonia']
world_map[region=='Timor-Leste', region := 'Timor_Leste']
world_map[region=='Trinidad', region := 'Trinidad_and_Tobago']
world_map[region=='Tobago', region := 'Trinidad_and_Tobago']
world_map[region=='Turks_and_Caicos_Islands', region := 'Turks_and_Caicos_islands']
world_map[region=='UK', region := 'United_Kingdom']
world_map[region=='Tanzania', region := 'United_Republic_of_Tanzania']
world_map[region=='USA', region := 'United_States_of_America']
world_map[region=='Swaziland', region := 'Eswatini']

# Countries that still don't match
print( data.frame(Only_in_the_data = setdiff(
  unique(casedist$countriesAndTerritories), 
  unique(world_map$region)) ) )
print( data.frame(Only_in_the_map = setdiff(
  unique(world_map$region), 
  unique(casedist$countriesAndTerritories)) ) )

 
# Add coordinates to the data tables
####################################

mapify <- function(dt, country1='country', country2='region') {
  merge(dt, world_map, by.x=country1, by.y=country2, all.x=TRUE, all.y=FALSE, allow.cartesian=TRUE)
}

# Code templates
## Don't merge data with the coordinates yet. Leave it until after any calculations.
# agecasenat <- mapify(agecasenat)
# casedist <- mapify(casedist, 'countriesAndTerritories')
# hosprate <- mapify(hosprate)
# natcasedeath <- mapify(natcasedeath)
# testingnat <- mapify(testing[level == 'national',])
## These tables include subregional detail. Neither the data nor the coordinates have subregional info for all countries. So, merging on subregions is problematic, and merging on countries is not sensible for the kind of data.
# testingsubnat <- testing[level != 'national',]
## movement
## subnatcaseday
## subnatcaseweek

# Colours
#########
seablue <- '#CCEEFF'
case_col <- '#FF0000'
death_col <- '#0055FF'
hosp_col <- '#555500'
icu_col <- '#995500'
test_col <- '#005500'

# Normalization
popnorm= 1e6
```



# Status

```{r}
endday <- unique(casedist[dateRep == max(dateRep), dateRep])
startday <- unique(casedist[dateRep == min(dateRep), dateRep])
endweek <- unique(casedist[year_week == max(year_week), year_week])
startweek <- unique(casedist[year_week == max(year_week), year_week])
```

Based on the latest available date in the table. Some countries may be slower at releasing/entering their data, and not have current data to show.

## Maps

### Global

```{r, fig.height=12, fig.width=12}
subDT <- merge(world_map[, .(region, long, lat, group, order)], 
               casedist[year_week==endweek, .(countriesAndTerritories, popData2019, cases_weekly, deaths_weekly)], 
               by.x='region', by.y='countriesAndTerritories', all.x=TRUE, all.y=FALSE, allow.cartesian=TRUE)

p1 <- ggplot(subDT, 
       aes(x=long, y=lat, group=group, fill=cases_weekly)) +
  geom_polygon(colour='black', size=0.01) +
  coord_cartesian(ylim=c(-60, 80), xlim=c(-180,180)) + # Crop giant Antarctica and empty Arctic
  scale_fill_gradient(low='white', high=case_col, na.value='grey50') +
  theme(panel.background=element_rect(fill=seablue),
        panel.grid=element_line(colour='white', size=0.1))

p2 <- ggplot(subDT, 
       aes(x=long, y=lat, group=group, fill=cases_weekly / popData2019 * popnorm)) +
  geom_polygon(colour='black', size=0.01) +
  coord_cartesian(ylim=c(-60, 80), xlim=c(-180,180)) + # Crop giant Antarctica and empty Arctic
  scale_fill_gradient(low='white', high=case_col, na.value='grey50', name=paste('cases_weekly\nper', popnorm)) +
  theme(panel.background=element_rect(fill=seablue),
        panel.grid=element_line(colour='white', size=0.1))

print( p1 / p2 )
ggsave('world_cases.png', plot = p1 / p2, device = png(), path = NULL, 
       scale = 1, width = 12, height = 12, units = "cm", dpi = 300, limitsize = TRUE)

p3 <- ggplot(subDT, 
       aes(x=long, y=lat, group=group, fill=deaths_weekly)) +
  geom_polygon(colour='black', size=0.01) +
  coord_cartesian(ylim=c(-60, 80), xlim=c(-180,180)) + # Crop giant Antarctica and empty Arctic
  scale_fill_gradient(low='white', high=death_col, na.value='grey50') +
  theme(panel.background=element_rect(fill=seablue),
        panel.grid=element_line(colour='white', size=0.1))

p4 <- ggplot(subDT, 
       aes(x=long, y=lat, group=group, fill=deaths_weekly / popData2019 * popnorm)) +
  geom_polygon(colour='black', size=0.01) +
  coord_cartesian(ylim=c(-60, 80), xlim=c(-180,180)) + # Crop giant Antarctica and empty Arctic
  scale_fill_gradient(low='white', high=death_col, na.value='grey50', name=paste('deaths_weekly\nper', popnorm)) +
  theme(panel.background=element_rect(fill=seablue),
        panel.grid=element_line(colour='white', size=0.1))


print( p3 / p4 )
ggsave('world_deaths.png', plot = p1 / p2, device = png(), path = NULL, 
       scale = 1, width = 12, height = 12, units = "cm", dpi = 300, limitsize = TRUE)
```

### Europe

```{r, fig.height=12, fig.width=10}
subDT <- merge(world_map[, .(region, long, lat, group, order)], 
               casedist[year_week==endweek & continentExp=='Europe', .(countriesAndTerritories, popData2019, cases_weekly, deaths_weekly)], 
               by.x='region', by.y='countriesAndTerritories', all.x=TRUE, all.y=FALSE, allow.cartesian=TRUE)

p1 <- ggplot(subDT, 
       aes(x=long, y=lat, group=group, fill=cases_weekly)) +
  geom_polygon(colour='black', size=0.01) +
  coord_cartesian(ylim=c(35, 70), xlim=c(-27,50)) + # Crop giant Antarctica and empty Arctic
  scale_fill_gradient(low='white', high=case_col, na.value='grey50') +
  theme(panel.background=element_rect(fill=seablue),
        panel.grid=element_line(colour='white', size=0.1))

p2 <- ggplot(subDT, 
       aes(x=long, y=lat, group=group, fill=cases_weekly / popData2019 * popnorm)) +
  geom_polygon(colour='black', size=0.01) +
  coord_cartesian(ylim=c(35, 70), xlim=c(-27,50)) + # Crop giant Antarctica and empty Arctic
  scale_fill_gradient(low='white', high=case_col, na.value='grey50', name=paste('cases_weekly\nper', popnorm)) +
  theme(panel.background=element_rect(fill=seablue),
        panel.grid=element_line(colour='white', size=0.1))

print( p1 / p2 )
ggsave('europe_cases.png', plot = p1 / p2, device = png(), path = NULL, 
       scale = 1, width = 10, height = 12, units = "cm", dpi = 300, limitsize = TRUE)

p3 <- ggplot(subDT, 
       aes(x=long, y=lat, group=group, fill=deaths_weekly)) +
  geom_polygon(colour='black', size=0.01) +
  coord_cartesian(ylim=c(35, 70), xlim=c(-27,50)) + # Crop giant Antarctica and empty Arctic
  scale_fill_gradient(low='white', high=death_col, na.value='grey50') +
  theme(panel.background=element_rect(fill=seablue),
        panel.grid=element_line(colour='white', size=0.1))

p4 <- ggplot(subDT, 
       aes(x=long, y=lat, group=group, fill=deaths_weekly / popData2019 * popnorm)) +
  geom_polygon(colour='black', size=0.01) +
  coord_cartesian(ylim=c(35, 70), xlim=c(-27,50)) + # Crop giant Antarctica and empty Arctic
  scale_fill_gradient(low='white', high=death_col, na.value='grey50', name=paste('deaths_weekly\nper', popnorm)) +
  theme(panel.background=element_rect(fill=seablue),
        panel.grid=element_line(colour='white', size=0.1))

print( p3 / p4 )
ggsave('europe_deaths.png', plot = p1 / p2, device = png(), path = NULL, 
       scale = 1, width = 10, height = 12, units = "cm", dpi = 300, limitsize = TRUE)
```



## Top 10s

### World's current worst

#### By cases

```{r}
# Worse 10 (or more) by weekly cases
subDT <- casedist[dateRep==endday & !is.na(cases_weekly), 
                  .(countriesAndTerritories, dateRep, cases_weekly, population_normalized = cases_weekly / popData2019 * popnorm)] [order(cases_weekly, decreasing=TRUE), ]

n <- max(10, nrow(subDT[sapply(subDT$cases_weekly, 
                               function(x) { 
                                 all.equal(subDT$cases_weekly[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))

print( head(subDT, n) )

# Worse 10 (or more) by weekly cases normalized
setorder(subDT, -population_normalized, na.last=TRUE)

n <- max(10, nrow(subDT[sapply(subDT$population_normalized, 
                               function(x) { 
                                 all.equal(subDT$population_normalized[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))
print( head(subDT, n) )
```

#### By deaths

```{r}
# Worse 10 (or more) by weekly deaths
subDT <- casedist[dateRep==endday & !is.na(deaths_weekly), 
                  .(countriesAndTerritories, dateRep, deaths_weekly, population_normalized = deaths_weekly / popData2019 * popnorm)] [order(deaths_weekly, decreasing=TRUE), ]

n <- max(10, nrow(subDT[sapply(subDT$deaths_weekly, 
                               function(x) { 
                                 all.equal(subDT$deaths_weekly[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))
print( head(subDT, n) )

# Worse 10 (or more) by weekly deaths normalized
setorder(subDT, -population_normalized, na.last=TRUE)

n <- max(10, nrow(subDT[sapply(subDT$population_normalized, 
                               function(x) { 
                                 all.equal(subDT$population_normalized[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))
print( head(subDT, n) )
```

### Europe's current worst

#### By cases

```{r}
# Worse 10 (or more) by weekly cases
subDT <- casedist[dateRep==endday & !is.na(cases_weekly) & continentExp == 'Europe', 
                  .(countriesAndTerritories, dateRep, cases_weekly, population_normalized = cases_weekly / popData2019 * popnorm)] [order(cases_weekly, decreasing=TRUE), ]

n <- max(10, nrow(subDT[sapply(subDT$cases_weekly, 
                               function(x) { 
                                 all.equal(subDT$cases_weekly[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))

print( head(subDT, n) )

# Worse 10 (or more) by weekly cases normalized
setorder(subDT, -population_normalized, na.last=TRUE)

n <- max(10, nrow(subDT[sapply(subDT$population_normalized, 
                               function(x) { 
                                 all.equal(subDT$population_normalized[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))
print( head(subDT, n) )
```

#### By deaths

```{r}
# Worse 10 (or more) by weekly deaths
subDT <- casedist[dateRep==endday & !is.na(deaths_weekly) & continentExp == 'Europe', 
                  .(countriesAndTerritories, dateRep, deaths_weekly, population_normalized = deaths_weekly / popData2019 * popnorm)] [order(deaths_weekly, decreasing=TRUE), ]

n <- max(10, nrow(subDT[sapply(subDT$deaths_weekly, 
                               function(x) { 
                                 all.equal(subDT$deaths_weekly[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))
print( head(subDT, n) )

# Worse 10 (or more) by weekly deaths normalized
setorder(subDT, -population_normalized, na.last=TRUE)

n <- max(10, nrow(subDT[sapply(subDT$population_normalized, 
                               function(x) { 
                                 all.equal(subDT$population_normalized[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))
print( head(subDT, n) )
```

### Europe's current best

#### By cases

```{r}
# Worse 10 (or more) by weekly cases
subDT <- casedist[dateRep==endday & !is.na(cases_weekly) & continentExp == 'Europe', 
                  .(countriesAndTerritories, dateRep, cases_weekly, population_normalized = cases_weekly / popData2019 * popnorm)] [order(cases_weekly, decreasing=FALSE), ]

n <- max(10, nrow(subDT[sapply(subDT$cases_weekly, 
                               function(x) { 
                                 all.equal(subDT$cases_weekly[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))

print( head(subDT, n) )

# Worse 10 (or more) by weekly cases normalized
setorder(subDT, population_normalized, na.last=TRUE)

n <- max(10, nrow(subDT[sapply(subDT$population_normalized, 
                               function(x) { 
                                 all.equal(subDT$population_normalized[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))
print( head(subDT, n) )
```

##]# By deaths

```{r}
# Worse 10 (or more) by weekly deaths
subDT <- casedist[dateRep==endday & !is.na(deaths_weekly) & continentExp == 'Europe', 
                  .(countriesAndTerritories, dateRep, deaths_weekly, population_normalized = deaths_weekly / popData2019 * popnorm)] [order(deaths_weekly, decreasing=FALSE), ]

n <- max(10, nrow(subDT[sapply(subDT$deaths_weekly, 
                               function(x) { 
                                 all.equal(subDT$deaths_weekly[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))
print( head(subDT, n) )

# Worse 10 (or more) by weekly deaths normalized
setorder(subDT, population_normalized, na.last=TRUE)

n <- max(10, nrow(subDT[sapply(subDT$population_normalized, 
                               function(x) { 
                                 all.equal(subDT$population_normalized[min(10, nrow(subDT))], x)
                               }) == TRUE, ]))
print( head(subDT, n) )
```

### Countries of personal interest

```{r}
print( 
  casedist[dateRep==endday & countriesAndTerritories %in% family_countries,
           .(countriesAndTerritories, dateRep, year_week, cases_weekly, population_normalized = cases_weekly / popData2019 * popnorm)] )

print( 
  casedist[dateRep==endday & countriesAndTerritories %in% family_countries,
           .(countriesAndTerritories, dateRep, year_week, deaths_weekly, population_normalized = cases_weekly / popData2019 * popnorm)] )


print( unique(
  movement[country %in% family_countries & week==endweek, 
           .(country, national_cases_7, national_positivity_rate)] ) )

print( 
  movement[country %in% family_countries & week==endweek, 
           .(country, region, subnational_cases_7, subnational_cases_14, subnational_rate_14)] )
```



# Timeline

## Map

```{r, fig.height=7, fig.width=12}
subDT <- merge(world_map[, .(region, long, lat, group, order)], 
               casedist[, .(countriesAndTerritories, popData2019, cases_weekly, deaths_weekly, year_week)], 
               by.x='region', by.y='countriesAndTerritories', all.x=TRUE, all.y=FALSE, allow.cartesian=TRUE)


# These are insanely slow, they are only

anim1 <- ggplot(subDT, 
       aes(x=long, y=lat, group=group, fill=cases_weekly / popData2019 * popnorm)) +
  geom_polygon(colour='black', size=0.01) +
  coord_cartesian(ylim=c(-60, 80), xlim=c(-180,180)) + # Crop giant Antarctica and empty Arctic
  scale_fill_gradient(low='white', high=case_col, na.value='grey50') +
  theme(panel.background=element_rect(fill=seablue),
        panel.grid=element_line(colour='white', size=0.1)) +
  labs('Week: {closest_state}') +
  transition_states(year_week,
                    transition_length = 0,
                    state_length = 1,
                    wrap=TRUE)

print( anim1 )
anim_save('world_cases.gif', animation = anim1, path = NULL, 
          device= png(), fps=1, nframes=length(unique(casedist$year_week)), 
          detail=0, start_pause=2, end_pause=5, fig.height=7, fig.width=12)

anim2 <- ggplot(subDT, 
       aes(x=long, y=lat, group=group, fill=deaths_weekly / popData2019 * popnorm)) +
  geom_polygon(colour='black', size=0.01) +
  coord_cartesian(ylim=c(-60, 80), xlim=c(-180,180)) + # Crop giant Antarctica and empty Arctic
  scale_fill_gradient(low='white', high=death_col, na.value='grey50', name=paste('deaths_weekly\nper', popnorm)) +
  theme(panel.background=element_rect(fill=seablue),
        panel.grid=element_line(colour='white', size=0.1))
  labs('Week: {closest_state}') +
  transition_states(year_week,
                    transition_length = 0.5,
                    state_length = 1,
                    wrap=TRUE)

print( anim2 )
anim_save('world_deaths.gif', animation = anim2, path = NULL, 
        device= png(), fps=1, nframes=length(unique(casedist$year_week)), 
        detail=0, start_pause=2, end_pause=5, fig.height=7, fig.width=12)

```


## Charts

### Growth in selected countries

```{r, fig.width=10, fig.height=15}
# Cumulative totals.
# In exponential growth, new cases are proportional to the total cases.
setorder(casedist, year_week, dateRep, countriesAndTerritories)
casedist[, cumulative_total_cases := cumsum(cases_weekly), by='countriesAndTerritories']
casedist[, cumulative_total_deaths := cumsum(deaths_weekly), by='countriesAndTerritories']

# The above doesn't take into account recovery. The all-time total is much larger than the number of active cases. Only active infections contribute to growth.
# Use 4-week rolling sum as an approximation for active total.
casedist[, monthly_cases := frollsum(cases_weekly, n=4), by='countriesAndTerritories']
casedist[, monthly_deaths := frollsum(deaths_weekly, n=4), by='countriesAndTerritories']


for (country in union(c(family_countries, other_countries), neighbour_countries)){
  # country <- 'Austria'
  
  p1 <- ggplot(casedist, 
               aes(x=cumulative_total_cases, y=cases_weekly, 
                   group=countriesAndTerritories)) +
    geom_line(colour='black', size=0.5, alpha=0.1) +
    scale_x_log10() +
    scale_y_log10() +
    geom_line(data=casedist[countriesAndTerritories==country,], 
              colour=case_col, size=1, alpha=1) +
    coord_cartesian(ylim=c(1,NA), xlim=c(1,NA)) +
    labs(title='Growth') +
    annotation_logticks(base=10, sides='lbrt') +
    theme_bw()
  
     
  p2 <- ggplot(casedist, 
               aes(x=cumulative_total_deaths, y=deaths_weekly, 
                   group=countriesAndTerritories)) +
    geom_line(colour='black', size=0.5, alpha=0.1) +
    scale_x_log10() +
    scale_y_log10() +
    geom_line(data=casedist[countriesAndTerritories==country,], 
              colour=death_col, size=1, alpha=1) +
    coord_cartesian(ylim=c(1,NA), xlim=c(1,NA)) +
    # labs(title=country) +
    annotation_logticks(base=10, sides='lbrt') +
    theme_bw()
  
  # print( p1 | p2 )
  
  
  p3 <- ggplot(casedist[countriesAndTerritories==country,], 
               aes(x=monthly_cases, # colour=dateRep,
                   y=cases_weekly)) + 
    # geom_point() +
    geom_path(size=rel(0.5), colour=case_col,
              arrow=grid::arrow(length=unit(0.15,'cm'), type='closed')) +
    scale_colour_gradientn(colours=c('black', 'black', 'black', case_col), guide='none') +
    labs(title='Progression') +
    theme_bw()
  
  
  p4 <- ggplot(casedist[countriesAndTerritories==country,], 
               aes(x=monthly_deaths, # colour=dateRep,
                   y=deaths_weekly)) +
    # geom_point() +
    geom_path(size=rel(0.5), colour=death_col,
              arrow=grid::arrow(length=unit(0.15,'cm'), type='closed')) +
    scale_colour_gradientn(colours=c('black', 'black', 'black', death_col), guide='none') +
    # labs(title=country) +
    theme_bw()

  # print( p3 | p4 )
  
  # print( (p1|p2)/(p3|p4) )
  
  
  ggplot(casedist, 
         aes(x=dateRep, y=cases_weekly / popData2019 * popnorm,
             group=countriesAndTerritories)) +
    geom_line(size=0.5, colour='black', alpha=0.1) +
    geom_line(data=casedist[countriesAndTerritories==country,],
              colour=case_col, size=1) +
    labs(title=country, x=NULL, y='Population-normalized weekly cases') +
    theme_bw() +
    theme(axis.text.x=element_text(angle=45, hjust=0.5, vjust=0.5))
  
  p6 <- ggplot(casedist, 
         aes(x=dateRep, y=deaths_weekly / popData2019 * popnorm,
             group=countriesAndTerritories)) +
    geom_line(size=0.5, colour='black', alpha=0.1) +
    geom_line(data=casedist[countriesAndTerritories==country,],
              colour=death_col, size=1) +
    labs(x=NULL, y='Population-normalized weekly deaths') +
    theme_bw()
  
  print( (p5|p6) / (p1|p2) / (p3|p4) )
}
```


