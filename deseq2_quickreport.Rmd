---
title: "DE report"
author: "Kimon Froussios"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    code_folding: hide
    toc: yes
---

\VignetteEngine{knitr::knitr}


```{r message=FALSE, warning=FALSE}
library(data.table)
library(matrixStats)
library(cluster)
library(pcaExplorer)
library(DESeq2)

library(tidyverse)
library(gridExtra)
library(ggrepel)
library(plotly)
library(htmltools)
# library(topGO)
```

Input

```{r}
## INPUT

basedir <- '/path/to/project/dir'
dedir <- 'path/to/DE/dir'
defile <- 'deseq2.RDS'
resdir <- NULL
```

Parameters

```{r echo=TRUE, collapse=FALSE}
# PARAMETERS


# DE selection cutoff
pcutoff <- 0.001
lfcthreshold <- 2

ndetop <- 100 # top DE genes
ntop <- 500    # top variable genes for PCA construction

# Max number of clusters to consider for k-means
cmax <- 15
# Hierarchical cxlustering distance method
clustmeth <- 'complete'
scl <- FALSE           # VST tranformed counts are already scaled.
ctr <- TRUE            # VST transformed counts are not centred on the cross-replicate mean.

dds <- readRDS(file.path(basedir, dedir, defile))
# Covariate categories
colDataAnn <- colData(dds)

# Set up gene_id => gene_name lookup.   (gene_id as both column and rowname)
anno_df <- NULL
# anno_df <- readRDS('~/mm_mart.RDS')
anno_df <- get_annotation(dds = dds,
                          biomart_dataset = "mmusculus_gene_ensembl",
                          idtype = "ensembl_gene_id")

samples <- NULL
# Define sample aliases and order (but order will be overriden by clustering)
#samples <- c(used1="alias1", used2="alias2", used3="alias3")
# OR alias names available in covariates field.
if ('Name' %in% names(colDataAnn)) {
  samples <- as.character(colDataAnn[['Name']])
}

# Determine number of k-means clusters by silhouette.
silhouette_score <- function(k, mat){
  km <- kmeans(mat, centers = k, nstart=100)
  ss <- silhouette(km$cluster, dist(mat))
  mean(ss[, 3])
}
```

Extract data

```{r message=FALSE}
# EXTRACT DATA

# Can't be bothered to make the format more flexible.
if(!is.null(anno_df)){
  stopifnot(all(c('gene_id', 'gene_name') %in% names(anno_df)))
}

# Paranoid
stopifnot(all( !is.na(rownames(dds)) ))
# Shit happens. Preserve gene_id when a gene_name is not available.
if(!is.null(anno_df)) {
  unmatched <- which(!rownames(dds) %in% anno_df$gene_id)
  if(length(unmatched) != 0){
    anno_df[unmatched, "gene_id"] <- rownames(dds)[unmatched]
    anno_df[unmatched, "gene_name"] <- rownames(dds)[unmatched]
  }
  stopifnot(all(anno_df$gene_id == rownames(dds)))
  stopifnot(all(!is.na(anno_df$gene_name)))
}


# Sanitise colDataAnn

# Sample names
if(!is.null(samples)){
  colDataAnn[["Name"]] <- samples      # Redundant if that's where I got the names to begin with, but covers all usage scenarios
} else {
  colDataAnn[["Name"]] <- rownames(colDataAnn)  # Ensure there are always values for Name, aliased or not.
}
colDataAnn[["Sample"]] <- rownames(colDataAnn)
  
# Covariate names 
ig <- names(colDataAnn)
ig <- ig[! ig %in% c('Sample', 'Name', 'sizeFactor')]


# Variance-shrunk counts

ddvst <- vst(dds, blind=FALSE)
colnames(ddvst) <- colDataAnn[colnames(ddvst), "Name"]

# Rename genes for plotting purposes
if (!is.null(anno_df)) {
  rownames(ddvst) <- anno_df$gene_name[match(rownames(ddvst), anno_df$gene_id)]
}

# Counts

ddc <- counts(dds)
# Rename samples
colnames(ddc) <- colDataAnn[colnames(ddc), "Name"]
# Rename genes
if (!is.null(anno_df)) {
  rownames(ddc) <- anno_df$gene_name[match(rownames(ddc), anno_df$gene_id)]
}
# Transformed counts
mat <- assay(ddvst)
# Centre on cross-sample means, to boost contrast.
rowmeans <- rowMeans2(mat)
mat <- apply(mat, 2, function(x) { x - rowmeans })


# Differential Expression

coefficients <- resultsNames(dds)
coefficients <- coefficients[coefficients != 'Intercept']
# DE
ddde <- lapply(coefficients, function(name) {
  # Shrunk LFC supposedly better for plotting and ranking
  res <- lfcShrink(dds, coef=name, type='apeglm')           # apeglm is the type recommended by DESeq2
                                                            # counts and DE significances are kept, but lfc is adjusted for the higher variance in low counts.
  de <- res %>% 
          as.data.frame() %>% 
          rownames_to_column(var='featureID') %>%
          mutate(mlp = -log10(padj)) %>%
          mutate(pass = mlp > -log10(pcutoff) & abs(log2FoldChange) >= lfcthreshold) %>%
          mutate(polar_dist = sqrt(mlp^2 + log2FoldChange^2)) %>%        # Distance from origin. lop10p is typically at least one order of magnitude 
                                                                              # bigger than lfc, so adjust for that.
          arrange(desc(polar_dist), desc(abs(log2FoldChange)), mlp)    # Prioritize points in the periphery
  # Rename genes
  if (!is.null(anno_df)) {         
    de[["feature"]] <- anno_df$gene_name[match(de$featureID, anno_df$gene_id)]
  } else {
    de[["feature"]] <- de[['featureID']]
  }
  
  if (!is.null(resdir)) {
    write.table(de, file=file.path(basedir, resdir, paste0(sub('.RDS', '', defile, fixed=TRUE), sub('^[^_]+', '', name), '.tsv')),
            sep="\t", quote = FALSE, row.names=FALSE, col.names=TRUE)
  }
  return(de)
})
names(ddde) <- coefficients


# Primary components

ddpc <- prcomp(t(assay(ddvst)))
```


# Pairwise sample correlations

### Based on the counts:

```{r}
ggplot( cor(ddc) %>% 
          as.data.frame() %>% 
          rownames_to_column(var="Sample1") %>% 
          gather(key="Sample2", value="Correlation", -Sample1), 
        aes(x=Sample1, y=Sample2, fill=Correlation)) +
  geom_tile() +
  theme(axis.text.x = element_text(angle=270, hjust = 0, vjust=0.5))
```

### Based on the variance-shrinkage tranformed counts:

```{r}
ggplot( cor(assay(ddvst)) %>% 
          as.data.frame() %>% 
          rownames_to_column(var="Sample1") %>% 
          gather(key="Sample2", value="Correlation", -Sample1), 
        aes(x=Sample1, y=Sample2, fill=Correlation)) +
  geom_tile() +
  theme(axis.text.x = element_text(angle=270, hjust = 0, vjust=0.5))
```


# Pairwise DE of each variable's conditions

```{r message=FALSE, warning=FALSE}
# Prepare

l3 <- htmltools::tagList()
i <- 1

for(name in coefficients) {         # de <- ddde[1]
  de <- ddde[[name]]
  # Histogram
  p1 <- ggplot(de, aes(x=log2FoldChange)) +
          geom_histogram(bins = 100, fill='grey75') +
          scale_y_sqrt() +
          # ggtitle(name) +
          theme(panel.background = element_rect(fill='white'), 
                # panel.grid.minor.y=element_line(colour='grey90'),
                panel.grid.major.y=element_line(colour='grey90'),
                axis.title.x=element_blank())
  
  # Static volcano
  p2 <- ggplot(de, aes(x=log2FoldChange, y=mlp, label=feature)) +
          geom_hline(yintercept=-log10(pcutoff), linetype = 'dotted', colour="lightblue") +
          geom_vline(xintercept=lfcthreshold, linetype = 'dotted', colour="lightblue") +
          geom_vline(xintercept=-lfcthreshold, linetype = 'dotted', colour="lightblue") +
          geom_point(shape=16, alpha=1, size=0.5) +
          labs(title=name, y='-log10 Padj', x='log2 FC') +
          theme(panel.background = element_rect(fill='white'),
                legend.position = "none")
  
  grid.arrange(p2, p1, nrow = 2, ncol = 1, widths = NULL, heights = c(4,1))
  
  # Top DE genes
  detop <- de %>% filter(pass)
  
  print(head(detop$feature, n=ndetop), quote=FALSE)
  
  # Extract vst counts.
  sm <- mat[detop$feature, ]
  
  # Cluster columns (hclust) and rows (by DE sign)
  chc <- hclust(dist(t(sm)), method=clustmeth)    # Same genes for each sample, should not need scaling.
  cord <- colnames(sm)[chc$order]
  mydata <- data.frame(sm, 
                       DE=vapply(detop$log2FoldChange, function(fc) {ifelse(fc>0, 'LFC (+)', 'LFC (-)')}, character(1)),
                       check.names = FALSE) %>% 
    rownames_to_column(var="Geneid") %>%
    gather(key="Sample", value="Expression", -Geneid, -DE) %>%
    mutate(Sample = factor(.$Sample, levels=cord))     # assign sample order 
  
  # Filtered interactive volcano
  p3 <- ggplot(detop, aes(x=log2FoldChange, y=mlp, label=feature)) +
          geom_hline(yintercept=-log10(pcutoff), linetype = 'dotted', colour="lightblue") +
          geom_vline(xintercept=lfcthreshold, linetype = 'dotted', colour="lightblue") +
          geom_vline(xintercept=-lfcthreshold, linetype = 'dotted', colour="lightblue") +
          geom_point(shape=16, size=1) +
          scale_y_continuous(limits=c(0, NA)) +
          labs(title=name, y='-log10 Padj', x='log2 FC') +
          theme(panel.background = element_rect(fill='white'))
  
  # Heatmap
  p4 <- ggplot(mydata, aes(x=Sample, y=Geneid, fill=Expression)) +
          facet_grid(DE ~ ., scales= "free", drop = TRUE) +
          geom_tile() +
          scale_fill_gradientn(colours=c("darkblue", "steelblue", "white", "darkorange", "darkred")) +
          # ggtitle(name) +
          theme(panel.background = element_rect(fill='white'),
                axis.text.y = element_blank(),
                axis.title.y = element_blank(),
                axis.ticks.y = element_blank(),
                axis.text.x = element_text(angle=270, hjust = 0, vjust=0.5),
                axis.title.x = element_blank(),
                plot.margin = margin(0.5, 0.5, 0.5, 2, "cm"),
                legend.position = 'right')
  
  l3[[i]] <- as_widget(subplot(ggplotly(p3), ggplotly(p4)))
  i <- i + 1
}
```

### Interactive volcano outliers

Reducing the number of points to maintain smooth worksheet interaction.

```{r fig.height=15, fig.width=12}
l3
```


# PCA

## Components

```{r message=FALSE}
# Principal Components 
grid.arrange(pcascree(ddpc, type="cev", title='Explained variance (cumulative)') + labs(y='Cumul. Proportion'),
             pcascree(ddpc, type="pev", title='Explained variance (individual)') + labs(y='Proportion'),
             nrow=2, ncol=1)
```

## Variable segregation

### 3D : PC1 + PC2 + PC3

```{r fig.height=10, fig.width=10}
# Global PCA
as_widget( 
  pcaplot3d(ddvst, intgroup=ig, ntop=ntop, pcX=1, pcY=2, pcZ=3, point_size = 1, text_labels=TRUE, title=paste('Primary components in', paste(ig, collapse = "+")))
)
```

### 2D : PC1 + PC2

```{r fig.height=7, fig.width=12}
# All variables.
print(
  pcaplot(ddvst, intgroup=ig, ntop=ntop, pcX=1, pcY=2, ellipse=FALSE, title=paste('Primary components in', paste(ig, collapse = ",")))
)

# Highlight one variable at a time.
l3 <- lapply(ig, function(varname) { 
                    return( 
                      pcaplot(ddvst, intgroup=varname, ntop=ntop, pcX=1, pcY=2, ellipse=FALSE, text_labels=FALSE, 
                              title=paste('Primary components by', varname))
                    )} )
do.call(grid.arrange, c(l3, ncol=2))
```

### 2D : PC1 + PC3

```{r fig.height=7, fig.width=12}
# All variables.
print(
  pcaplot(ddvst, intgroup=ig, ntop=ntop, pcX=1, pcY=3, ellipse=FALSE, title=paste('Primary components in', paste(ig, collapse = ",")))
)

# Highlight one variable at a time.
l3 <- lapply(ig, function(varname) { 
                    return( 
                      pcaplot(ddvst, intgroup=varname, ntop=ntop, pcX=1, pcY=3, ellipse=FALSE, text_labels=FALSE, 
                              title=paste('Primary components by', varname))
                    )} )
do.call(grid.arrange, c(l3, ncol=2))
```

### 2D : PC2 + PC3

```{r fig.height=7, fig.width=12}
# All variables.
print(
  pcaplot(ddvst, intgroup=ig, ntop=ntop, pcX=3, pcY=2, ellipse=FALSE, title=paste('Primary components in', paste(ig, collapse = ",")))
)

# Highlight one variable at a time.
l3 <- lapply(ig, function(varname) { 
                    return( 
                      pcaplot(ddvst, intgroup=varname, ntop=ntop, pcX=3, pcY=2, ellipse=FALSE, text_labels=FALSE, 
                              title=paste('Primary components by', varname))
                    )} )
do.call(grid.arrange, c(l3, ncol=2))
```


<!-- ### Further components -->

```{r fig.height=5, fig.width=12}
# for (P in 1:3) {
#   for (p in 4:5) {
#     l3 <- lapply(ig, function(varname) { 
#                       return(
#                         pcaplot(ddvst, intgroup=varname, ntop=ntop, pcX=P, pcY=p, ellipse=FALSE, text_labels = FALSE) )
#                     } )
#     do.call(grid.arrange, c(l3, ncol=2))
#   }
# }
```


## Most influential genes for the first 3 PCs

```{r}
message("Genes with the (absolute) highest loadings on PC1:")
topn <- floor(ntop / 2 / 10 + 0.5)

hi1 <- hi_loadings(ddpc, whichpc=1, topN=topn, exprTable=ddc)
rM <- rowMeans2(hi1)
hi1 <- hi1 %>% as.data.frame() %>% 
  rownames_to_column(var='Geneid') %>%
  mutate(rowmeans = rM) %>%
  arrange(desc(rowmeans)) %>% 
  dplyr::select(Geneid) %>% 
  .$Geneid
  noquote( hi1 )

message("Genes with the highest (absolute) loadings on PC2:")
hi2 <- hi_loadings(ddpc, whichpc=2, topN=topn, exprTable=ddc)
rM <- rowMeans2(hi2)
hi2 <- hi2 %>% as.data.frame() %>% 
  rownames_to_column(var='Geneid') %>%
  mutate(rowmeans = rM) %>%
  arrange(desc(rowmeans)) %>% 
  dplyr::select(Geneid) %>% 
  .$Geneid
  noquote( hi2 )
  
message("Genes with the highest (absolute) loadings on PC3:")
hi3 <- hi_loadings(ddpc, whichpc=3, topN=topn, exprTable=ddc)
rM <- rowMeans2(hi3)
hi3 <- hi3 %>% as.data.frame() %>% 
  rownames_to_column(var='Geneid') %>%
  mutate(rowmeans = rM) %>%
  arrange(desc(rowmeans)) %>% 
  dplyr::select(Geneid) %>% 
  .$Geneid
  noquote( hi3 )
```

```{r}
hi <- union(union(hi1, hi2), hi3)
print( c('union'=length(hi), 'intersection'=length(intersect(intersect(hi1,hi2), hi3))) )
```


# Top variable genes

As used to define the Principle Components.

## Expression

Optimal number of clusters.

```{r}
# Cluster the genes.

# Top variable genes
topVarGenes <- order(rowVars(mat), decreasing=TRUE)[1:ntop]
mat <- mat[topVarGenes,]

# Find optimal number of clusters by silhouette.
sil <- data.frame(k = 2:min(cmax, nrow(mat)-1),
                  avg_sil = vapply(2:min(cmax, nrow(mat)-1), function(k) { silhouette_score(k, mat) }, double(1)) )
copt <-sil$k[sil$avg_sil == max(sil$avg_sil)]

p1 <- ggplot(sil, aes(x=k, y=avg_sil)) +
  geom_point() +
  geom_line() +
  geom_vline(xintercept=copt, linetype='dotted') +
  scale_x_continuous(breaks=seq(0,cmax,4), limits=c(0, cmax+1), expand=c(0,0)) +
  labs(title="Infering optimal number of clusters", x='Number of Groups', y='Average Silhouette Scores') + 
  theme_bw()

# Confirm number of clusters by elbow.
kink <- as.data.frame(lapply(1:100, function(i){
            c( (nrow(mat) - 1) * sum(apply(mat, 2, var)), 
               vapply(2:cmax, function(k) { 
                 sum( kmeans(mat, centers=k)$withinss )
                }, double(1)) )
        })) %>%
  mutate(nc = 1:cmax) %>%
  gather(key="iter", value=wss, -nc)

p2 <-ggplot(kink, aes(x=nc, y=wss, colour=iter)) +
  # geom_point() +
  geom_line(alpha=0.1) +
  geom_vline(xintercept=copt, linetype='dotted') +
  scale_x_continuous(breaks=seq(0,cmax,4), limits=c(0, cmax+1), expand=c(0,0)) +
  labs(x="Number of Groups", y="Within-group Sums of Squares") +
  theme_bw() +
  theme(legend.position = "none")

grid.arrange( arrangeGrob(p1, p2, nrow=2) )

# K-Means Cluster Analysis
fit <- kmeans(mat, copt, nstart=100)
# get cluster means
aggregate(mat, by=list(fit$cluster), FUN=mean)
```

Centred, variance-stablised expression matrix.

```{r fig.height=12, fig.width=10}

# Cluster the samples.
chc <- hclust(dist(t(mat)), method=clustmeth)    # Same genes for each sample, should not need scaling.
cord <- colnames(mat)[chc$order]

# Append cluster assignment
mydata <- data.frame(mat, cluster=as.factor(fit$cluster), check.names = FALSE) %>% 
  mutate(Geneid = rownames(mat)) %>%
  gather(key="Sample", value="Expression", -Geneid, -cluster) %>%
  mutate(Sample = factor(.$Sample, levels=cord))     # assign sample order 
      
ggplot(mydata, aes(x=Sample, y=Geneid, fill=Expression)) +
  facet_grid(cluster ~ ., scales= "free", drop = TRUE) +
  geom_tile() +
  scale_fill_gradientn(colours=c("darkblue", "steelblue", "white", "darkorange", "darkred")) +
  ggtitle( paste('Top', ntop, 'high-variance genes used for PCA') ) +
  theme(panel.background = element_rect(fill='white'),
        axis.text.y = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.text.x = element_text(angle=270, hjust = 0, vjust=0.5),
        axis.title.x = element_blank())
```

Genes

```{r}
# Genes per cluster
mydata %>% group_by(cluster) %>%
  summarise(Num_of_Genes = length(unique(Geneid)))

for (x in unique(mydata$cluster)){
  print( paste('Genes in cluster', as.character(x)) )
  print( mydata %>% filter(cluster==x) %>% dplyr::select(Geneid) %>% .$Geneid %>% unique(), quote=FALSE )
}
```

### Expression of the highest loading genes in the first 3 PCs

```{r fig.height=12, fig.width=12}
order_heat <- function(x, y) {
  sm <- y[rownames(y) %in% x,]
  
  # Find optimal number of clusters by silhouette.
  sil <- data.frame(k = 2:min(cmax, nrow(sm) -1),
                    avg_sil = vapply(2:min(cmax, nrow(sm)-1), function(k) { silhouette_score(k, sm) }, double(1)) )
  copt <-sil$k[sil$avg_sil == max(sil$avg_sil)]
  # Cluster the samples.
  chc <- hclust(dist(t(sm)), method=clustmeth)    # Same genes for each sample, should not need scaling.
  cord <- colnames(sm)[chc$order]

  fit <- kmeans(sm, copt, nstart=100)
  
  # Append cluster assignment
  mydata <- data.frame(sm, cluster=as.factor(fit$cluster), check.names = FALSE) %>% 
    mutate(Geneid = rownames(sm)) %>%
    gather(key="Sample", value="Expression", -Geneid, -cluster) %>%
    mutate(Sample = factor(.$Sample, levels=cord))     # assign sample order 
  
  return(mydata)
}

p1 <- ggplot(order_heat(hi1, mat), aes(x=Sample, y=Geneid, fill=Expression)) +
    facet_grid(cluster ~ ., scales= "free", drop = TRUE) +
    geom_tile() +
    scale_fill_gradientn(colours=c("darkblue", "steelblue", "white", "darkorange", "darkred")) +
    ggtitle( 'PC1' ) +
    theme(panel.background = element_rect(fill='white'),
          # axis.text.y = element_blank(),
          # axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.text.x = element_text(angle=270, hjust = 0, vjust=0.5),
          axis.title.x = element_blank(),
          legend.position = 'top')

p2 <- ggplot(order_heat(hi2, mat), aes(x=Sample, y=Geneid, fill=Expression)) +
    facet_grid(cluster ~ ., scales= "free", drop = TRUE) +
    geom_tile() +
    scale_fill_gradientn(colours=c("darkblue", "steelblue", "white", "darkorange", "darkred")) +
    ggtitle( 'PC2' ) +
    theme(panel.background = element_rect(fill='white'),
          # axis.text.y = element_blank(),
          # axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.text.x = element_text(angle=270, hjust = 0, vjust=0.5),
          axis.title = element_blank(),
          legend.position = 'top')

p3 <- ggplot(order_heat(hi3, mat), aes(x=Sample, y=Geneid, fill=Expression)) +
    facet_grid(cluster ~ ., scales= "free", drop = TRUE) +
    geom_tile() +
    scale_fill_gradientn(colours=c("darkblue", "steelblue", "white", "darkorange", "darkred")) +
    ggtitle( 'PC3' ) +
    theme(panel.background = element_rect(fill='white'),
          # axis.text.y = element_blank(),
          # axis.title.y = element_blank(),
          axis.ticks.y = element_blank(),
          axis.text.x = element_text(angle=270, hjust = 0, vjust=0.5),
          axis.title = element_blank(),
         legend.position = 'top')

grid.arrange(arrangeGrob(p1, p2, p3, ncol=3))
```





